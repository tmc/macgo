package signalhandler

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"syscall"
	"testing"
	"time"

	"github.com/tmc/misc/macgo"
)

func TestInit(t *testing.T) {
	// Test that the init function properly sets up the relaunch function
	// This is verified by checking that the relaunch function was set
	// (we can't easily test the actual function without integration tests)

	// The init function should have run automatically
	// We can verify this by checking if the module loaded correctly
}

func TestImprovedRelaunchBasic(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test basic parameter handling
	appPath := "/Applications/Test.app"
	execPath := "/usr/bin/test"
	args := []string{"-n", "TestApp"}

	// Mock the function to avoid actual execution
	originalLookPath := exec.LookPath
	exec.LookPath = func(file string) (string, error) {
		if file == "open" {
			return "/usr/bin/open", nil
		}
		return originalLookPath(file)
	}
	defer func() { exec.LookPath = originalLookPath }()

	// This test mainly verifies the function doesn't panic with valid inputs
	// Actual execution would require a real app bundle
	defer func() {
		if r := recover(); r != nil {
			t.Errorf("improvedRelaunch panicked: %v", r)
		}
	}()

	// We need to run this in a separate process to avoid affecting the test process
	// For now, we'll just verify the function signature and basic error handling
}

func TestImprovedRelaunchLookPathError(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test handling of exec.LookPath error
	originalLookPath := exec.LookPath
	exec.LookPath = func(file string) (string, error) {
		if file == "open" {
			return "", fmt.Errorf("command not found")
		}
		return originalLookPath(file)
	}
	defer func() { exec.LookPath = originalLookPath }()

	// Capture debug output to verify error handling
	originalDebugFunc := macgo.Debug
	var debugMessages []string
	macgo.Debug = func(format string, args ...interface{}) {
		debugMessages = append(debugMessages, fmt.Sprintf(format, args...))
	}
	defer func() { macgo.Debug = originalDebugFunc }()

	// Test parameters
	appPath := "/Applications/Test.app"
	execPath := "/usr/bin/test"
	args := []string{"-n", "TestApp"}

	// This should handle the error gracefully
	func() {
		defer func() {
			if r := recover(); r != nil {
				t.Errorf("improvedRelaunch panicked on LookPath error: %v", r)
			}
		}()

		// Run in a controlled way to avoid actual execution
		// The function should return early on LookPath error
		improvedRelaunch(appPath, execPath, args)
	}()

	// Verify error was logged
	found := false
	for _, msg := range debugMessages {
		if strings.Contains(msg, "error finding open command") {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected error finding open command to be logged")
	}
}

func TestImprovedRelaunchEnvironmentSetup(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test that MACGO_NO_RELAUNCH environment variable is set
	originalEnv := os.Getenv("MACGO_NO_RELAUNCH")
	defer func() {
		if originalEnv != "" {
			os.Setenv("MACGO_NO_RELAUNCH", originalEnv)
		} else {
			os.Unsetenv("MACGO_NO_RELAUNCH")
		}
	}()

	// Clear the environment variable
	os.Unsetenv("MACGO_NO_RELAUNCH")

	// Mock exec.LookPath to return error quickly
	originalLookPath := exec.LookPath
	exec.LookPath = func(file string) (string, error) {
		if file == "open" {
			// Check if environment variable was set
			if os.Getenv("MACGO_NO_RELAUNCH") != "1" {
				t.Error("Expected MACGO_NO_RELAUNCH to be set to '1'")
			}
			return "", fmt.Errorf("test error")
		}
		return originalLookPath(file)
	}
	defer func() { exec.LookPath = originalLookPath }()

	// Test parameters
	appPath := "/Applications/Test.app"
	execPath := "/usr/bin/test"
	args := []string{"-n", "TestApp"}

	// Run the function
	improvedRelaunch(appPath, execPath, args)
}

func TestImprovedRelaunchCommandCreation(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test command creation and configuration
	var createdCmd *exec.Cmd

	// Mock exec.LookPath and exec.Cmd.Start to capture command details
	originalLookPath := exec.LookPath
	exec.LookPath = func(file string) (string, error) {
		if file == "open" {
			return "/usr/bin/open", nil
		}
		return originalLookPath(file)
	}
	defer func() { exec.LookPath = originalLookPath }()

	// We need to test the command creation logic
	// This is complex because we need to intercept the command creation
	// For now, we'll test the basic setup that we can verify
	testAppPath := "/Applications/Test.app"
	testExecPath := "/usr/bin/test"
	testArgs := []string{"-n", "TestApp"}

	// Test that the function creates the command with correct parameters
	// The actual verification would require more complex mocking
	// For this test, we'll verify the function runs without panic
	defer func() {
		if r := recover(); r != nil {
			t.Errorf("Command creation caused panic: %v", r)
		}
	}()

	// Mock the command start to avoid actual execution
	originalCommand := exec.Command
	exec.Command = func(name string, arg ...string) *exec.Cmd {
		cmd := &exec.Cmd{
			Path: name,
			Args: append([]string{name}, arg...),
		}
		createdCmd = cmd
		return cmd
	}
	defer func() { exec.Command = originalCommand }()

	// This would normally run the command, but we'll intercept it
	// The test mainly verifies setup doesn't panic
}

func TestSignalForwardingSetup(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test signal forwarding logic in isolation
	// This tests the signal channel setup and forwarding logic

	// Create a mock process
	cmd := &exec.Cmd{
		Path: "/bin/echo",
		Args: []string{"/bin/echo", "test"},
	}

	// Start the command
	err := cmd.Start()
	if err != nil {
		t.Fatalf("Failed to start mock command: %v", err)
	}

	// Test signal channel creation
	c := make(chan os.Signal, 100)
	if cap(c) != 100 {
		t.Errorf("Expected signal channel capacity 100, got %d", cap(c))
	}

	// Test signal forwarding logic
	testSignals := []syscall.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGCHLD, // This should be skipped
		syscall.SIGTSTP,
	}

	// Mock the syscall.Kill function to capture signals
	var sentSignals []syscall.Signal
	var sentPids []int

	originalKill := syscall.Kill
	syscall.Kill = func(pid int, sig syscall.Signal) error {
		sentSignals = append(sentSignals, sig)
		sentPids = append(sentPids, pid)
		return nil
	}
	defer func() { syscall.Kill = originalKill }()

	// Test the signal forwarding logic
	for _, sig := range testSignals {
		// Skip SIGCHLD as it should be filtered out
		if sig == syscall.SIGCHLD {
			continue
		}

		// Test that signals are sent to the process group (negative PID)
		expectedPid := -cmd.Process.Pid

		// Simulate the signal forwarding
		if sig != syscall.SIGCHLD {
			syscall.Kill(expectedPid, sig)
		}
	}

	// Verify signals were sent correctly
	expectedSignals := []syscall.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGTSTP,
	}

	if len(sentSignals) != len(expectedSignals) {
		t.Errorf("Expected %d signals, got %d", len(expectedSignals), len(sentSignals))
	}

	for i, expectedSig := range expectedSignals {
		if i < len(sentSignals) && sentSignals[i] != expectedSig {
			t.Errorf("Expected signal %v, got %v", expectedSig, sentSignals[i])
		}
	}

	// Verify PIDs are negative (process group)
	expectedPid := -cmd.Process.Pid
	for i, pid := range sentPids {
		if pid != expectedPid {
			t.Errorf("Signal %d: expected PID %d, got %d", i, expectedPid, pid)
		}
	}

	// Clean up
	if cmd.Process != nil {
		cmd.Process.Kill()
	}
	close(c)
}

func TestTerminalSignalHandling(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test special handling of terminal signals
	terminalSignals := []syscall.Signal{
		syscall.SIGTSTP,
		syscall.SIGTTIN,
		syscall.SIGTTOU,
	}

	// Mock syscall.Kill to capture signals
	var sentSignals []syscall.Signal
	var sentPids []int

	originalKill := syscall.Kill
	syscall.Kill = func(pid int, sig syscall.Signal) error {
		sentSignals = append(sentSignals, sig)
		sentPids = append(sentPids, pid)
		return nil
	}
	defer func() { syscall.Kill = originalKill }()

	currentPid := syscall.Getpid()

	// Test that terminal signals trigger SIGSTOP to current process
	for _, sig := range terminalSignals {
		// Clear previous signals
		sentSignals = nil
		sentPids = nil

		// Simulate terminal signal handling
		if sig == syscall.SIGTSTP || sig == syscall.SIGTTIN || sig == syscall.SIGTTOU {
			syscall.Kill(currentPid, syscall.SIGSTOP)
		}

		// Verify SIGSTOP was sent to current process
		if len(sentSignals) != 1 {
			t.Errorf("Expected 1 signal for %v, got %d", sig, len(sentSignals))
			continue
		}

		if sentSignals[0] != syscall.SIGSTOP {
			t.Errorf("Expected SIGSTOP for terminal signal %v, got %v", sig, sentSignals[0])
		}

		if sentPids[0] != currentPid {
			t.Errorf("Expected signal sent to current PID %d, got %d", currentPid, sentPids[0])
		}
	}
}

func TestSignalSkipping(t *testing.T) {
	// Test that SIGCHLD is properly skipped
	signals := []syscall.Signal{
		syscall.SIGINT,
		syscall.SIGCHLD, // This should be skipped
		syscall.SIGTERM,
	}

	var processedSignals []syscall.Signal

	// Simulate the signal processing logic
	for _, sig := range signals {
		// Skip SIGCHLD as we don't need to forward it
		if sig == syscall.SIGCHLD {
			continue
		}
		processedSignals = append(processedSignals, sig)
	}

	// Verify SIGCHLD was skipped
	expectedSignals := []syscall.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
	}

	if len(processedSignals) != len(expectedSignals) {
		t.Errorf("Expected %d processed signals, got %d", len(expectedSignals), len(processedSignals))
	}

	for i, expected := range expectedSignals {
		if i < len(processedSignals) && processedSignals[i] != expected {
			t.Errorf("Expected signal %v, got %v", expected, processedSignals[i])
		}
	}

	// Verify SIGCHLD is not in the processed list
	for _, sig := range processedSignals {
		if sig == syscall.SIGCHLD {
			t.Error("SIGCHLD should have been skipped but was processed")
		}
	}
}

func TestProcessGroupConfiguration(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test that the command is configured with proper process group settings
	cmd := &exec.Cmd{
		Path: "/bin/echo",
		Args: []string{"/bin/echo", "test"},
		SysProcAttr: &syscall.SysProcAttr{
			Setpgid: true,
			Pgid:    0,
		},
	}

	// Verify the SysProcAttr settings
	if cmd.SysProcAttr == nil {
		t.Error("Expected SysProcAttr to be set")
	} else {
		if !cmd.SysProcAttr.Setpgid {
			t.Error("Expected Setpgid to be true")
		}
		if cmd.SysProcAttr.Pgid != 0 {
			t.Errorf("Expected Pgid to be 0, got %d", cmd.SysProcAttr.Pgid)
		}
	}
}

func TestErrorHandling(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test various error scenarios
	tests := []struct {
		name        string
		setupError  func() func()
		expectError bool
	}{
		{
			name: "Command start error",
			setupError: func() func() {
				// Mock exec.LookPath to return a non-executable path
				originalLookPath := exec.LookPath
				exec.LookPath = func(file string) (string, error) {
					if file == "open" {
						return "/dev/null", nil // Non-executable
					}
					return originalLookPath(file)
				}
				return func() { exec.LookPath = originalLookPath }
			},
			expectError: true,
		},
		{
			name: "Signal forwarding error",
			setupError: func() func() {
				// Mock syscall.Kill to return an error
				originalKill := syscall.Kill
				syscall.Kill = func(pid int, sig syscall.Signal) error {
					return fmt.Errorf("mock signal error")
				}
				return func() { syscall.Kill = originalKill }
			},
			expectError: false, // Signal errors should be handled gracefully
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleanup := tt.setupError()
			defer cleanup()

			// Capture debug messages
			var debugMessages []string
			originalDebugFunc := macgo.Debug
			macgo.Debug = func(format string, args ...interface{}) {
				debugMessages = append(debugMessages, fmt.Sprintf(format, args...))
			}
			defer func() { macgo.Debug = originalDebugFunc }()

			// Test error handling
			defer func() {
				if r := recover(); r != nil {
					if !tt.expectError {
						t.Errorf("Unexpected panic: %v", r)
					}
				}
			}()

			// The actual test would need to be more controlled
			// For now, we verify the setup doesn't cause issues
		})
	}
}

func TestSignalChannelBuffer(t *testing.T) {
	// Test that signal channel has appropriate buffer size
	expectedBufferSize := 100

	c := make(chan os.Signal, expectedBufferSize)

	if cap(c) != expectedBufferSize {
		t.Errorf("Expected signal channel capacity %d, got %d", expectedBufferSize, cap(c))
	}

	// Test that the channel can handle burst signals
	testSignals := []os.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGHUP,
	}

	// Send multiple signals without blocking
	for i := 0; i < expectedBufferSize/2; i++ {
		for _, sig := range testSignals {
			select {
			case c <- sig:
				// Signal sent successfully
			default:
				t.Errorf("Signal channel blocked unexpectedly at iteration %d", i)
			}
		}
	}

	// Verify we can still receive signals
	for i := 0; i < len(testSignals)*expectedBufferSize/2; i++ {
		select {
		case sig := <-c:
			if sig == nil {
				t.Error("Received nil signal")
			}
		default:
			t.Errorf("No signal available at iteration %d", i)
		}
	}

	close(c)
}

func TestIntegrationWithMacgo(t *testing.T) {
	// Test integration with the main macgo package
	// This verifies that the signalhandler package properly integrates

	// The init function should have set up the relaunch function
	// We can't easily test this directly, but we can verify the package loads

	// Test that macgo functions are available
	if macgo.Debug == nil {
		t.Error("Expected macgo.Debug to be available")
	}

	// Test that we can call macgo functions without panic
	defer func() {
		if r := recover(); r != nil {
			t.Errorf("Calling macgo functions caused panic: %v", r)
		}
	}()

	// Test debug function
	macgo.Debug("Test debug message from signalhandler test")
}

func TestRaceConditions(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping race condition test in short mode")
	}

	// Test concurrent access to signal handling
	const numGoroutines = 10
	done := make(chan bool, numGoroutines)

	// Create a signal channel
	c := make(chan os.Signal, 100)

	// Start multiple goroutines that simulate signal handling
	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			defer func() { done <- true }()

			// Simulate signal processing
			testSignals := []os.Signal{
				syscall.SIGINT,
				syscall.SIGTERM,
				syscall.SIGHUP,
			}

			for _, sig := range testSignals {
				select {
				case c <- sig:
					// Signal sent
				default:
					// Channel full, skip
				}
			}

			// Simulate signal receiving
			select {
			case <-c:
				// Signal received
			default:
				// No signal available
			}
		}(i)
	}

	// Wait for all goroutines to complete
	for i := 0; i < numGoroutines; i++ {
		select {
		case <-done:
			// Goroutine completed
		case <-time.After(5 * time.Second):
			t.Fatal("Goroutine did not complete within timeout")
		}
	}

	close(c)
}

func TestExitCodeHandling(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test on non-macOS platform")
	}

	// Test that exit codes are properly handled
	// This tests the exit code extraction logic

	// Create a mock ExitError
	exitError := &exec.ExitError{
		ProcessState: &os.ProcessState{},
	}

	// Test exit code extraction
	// In a real scenario, this would involve actual process execution
	// For this test, we verify the error type checking

	if _, ok := exitError.(*exec.ExitError); !ok {
		t.Error("Expected ExitError type")
	}

	// Test that the function checks for Exited() status
	// This is part of the error handling logic in improvedRelaunch
}

// Benchmark tests
func BenchmarkSignalChannelCreation(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		c := make(chan os.Signal, 100)
		close(c)
	}
}

func BenchmarkSignalForwarding(b *testing.B) {
	if runtime.GOOS != "darwin" {
		b.Skip("Skipping macOS-specific benchmark on non-macOS platform")
	}

	// Mock syscall.Kill for benchmarking
	originalKill := syscall.Kill
	syscall.Kill = func(pid int, sig syscall.Signal) error {
		return nil
	}
	defer func() { syscall.Kill = originalKill }()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Simulate signal forwarding
		syscall.Kill(-1000, syscall.SIGINT)
	}
}

func BenchmarkSignalChannelOperations(b *testing.B) {
	c := make(chan os.Signal, 100)
	defer close(c)

	signals := []os.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGHUP,
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sig := signals[i%len(signals)]
		select {
		case c <- sig:
			// Sent
		default:
			// Channel full
		}

		select {
		case <-c:
			// Received
		default:
			// No signal
		}
	}
}
