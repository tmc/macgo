
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auto: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tmc/misc/macgo/auto/auto.go (0.0%)</option>
				
				<option value="file1">github.com/tmc/misc/macgo/auto/sandbox/readonly/readonly.go (0.0%)</option>
				
				<option value="file2">github.com/tmc/misc/macgo/auto/sandbox/sandbox.go (0.0%)</option>
				
				<option value="file3">github.com/tmc/misc/macgo/auto/sandbox/signalhandler/signalhandler.go (0.0%)</option>
				
				<option value="file4">github.com/tmc/misc/macgo/cmd/macgo-debug/main.go (0.0%)</option>
				
				<option value="file5">github.com/tmc/misc/macgo/debug/debug.go (0.0%)</option>
				
				<option value="file6">github.com/tmc/misc/macgo/entitlements/calendar/calendar.go (100.0%)</option>
				
				<option value="file7">github.com/tmc/misc/macgo/entitlements/camera/camera.go (100.0%)</option>
				
				<option value="file8">github.com/tmc/misc/macgo/entitlements/contacts/contacts.go (100.0%)</option>
				
				<option value="file9">github.com/tmc/misc/macgo/entitlements/entitlements.go (98.0%)</option>
				
				<option value="file10">github.com/tmc/misc/macgo/entitlements/location/location.go (100.0%)</option>
				
				<option value="file11">github.com/tmc/misc/macgo/entitlements/mic/mic.go (100.0%)</option>
				
				<option value="file12">github.com/tmc/misc/macgo/entitlements/photos/photos.go (100.0%)</option>
				
				<option value="file13">github.com/tmc/misc/macgo/entitlements/reminders/reminders.go (100.0%)</option>
				
				<option value="file14">github.com/tmc/misc/macgo/examples/advanced/main.go (0.0%)</option>
				
				<option value="file15">github.com/tmc/misc/macgo/examples/custom-template/main.go (0.0%)</option>
				
				<option value="file16">github.com/tmc/misc/macgo/examples/customization/main.go (0.0%)</option>
				
				<option value="file17">github.com/tmc/misc/macgo/examples/debug-features/main.go (0.0%)</option>
				
				<option value="file18">github.com/tmc/misc/macgo/examples/entitlements/main.go (0.0%)</option>
				
				<option value="file19">github.com/tmc/misc/macgo/examples/hello/main.go (0.0%)</option>
				
				<option value="file20">github.com/tmc/misc/macgo/examples/legacy-signals/main.go (0.0%)</option>
				
				<option value="file21">github.com/tmc/misc/macgo/examples/macgo-child-test/main.go (0.0%)</option>
				
				<option value="file22">github.com/tmc/misc/macgo/examples/minimal/main.go (0.0%)</option>
				
				<option value="file23">github.com/tmc/misc/macgo/examples/sandbox-best-practices/main.go (0.0%)</option>
				
				<option value="file24">github.com/tmc/misc/macgo/examples/sandboxed-file-exec/main.go (0.0%)</option>
				
				<option value="file25">github.com/tmc/misc/macgo/examples/sandboxed-osascript/main.go (0.0%)</option>
				
				<option value="file26">github.com/tmc/misc/macgo/examples/security-bookmarks/main.go (0.0%)</option>
				
				<option value="file27">github.com/tmc/misc/macgo/examples/signal-capture/main.go (0.0%)</option>
				
				<option value="file28">github.com/tmc/misc/macgo/examples/signal-debug/main.go (0.0%)</option>
				
				<option value="file29">github.com/tmc/misc/macgo/examples/signal-test/main.go (0.0%)</option>
				
				<option value="file30">github.com/tmc/misc/macgo/examples/simple/main.go (0.0%)</option>
				
				<option value="file31">github.com/tmc/misc/macgo/examples/specific-folder-access/main.go (0.0%)</option>
				
				<option value="file32">github.com/tmc/misc/macgo/examples/test-output/main.go (0.0%)</option>
				
				<option value="file33">github.com/tmc/misc/macgo/signalhandler/signalhandler.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package auto provides automatic initialization for macgo.
//
// Import this package to automatically initialize macgo on startup:
//
//        import (
//            _ "github.com/tmc/misc/macgo/auto"
//        )
package auto

import (
        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Start macgo
        // This will create the app bundle and relaunch the application if necessary.
        macgo.Start()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package readonly provides automatic initialization for macgo with app sandboxing
// and read-only file access to user-selected files.
//
// Import this package to automatically set up app sandboxing with read-only access:
//
//        import (
//            _ "github.com/tmc/misc/macgo/auto/sandbox/readonly"
//        )
//
// This will automatically enable app sandboxing with read-only access to
// user-selected files and create the app bundle.
package readonly

import (
        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Enable app sandbox with read-only file access
        macgo.RequestEntitlements(
                macgo.EntAppSandbox,
                macgo.EntUserSelectedReadOnly,
        )
        // Start macgo
        macgo.Start()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package sandbox provides automatic initialization for macgo with app sandboxing.
//
// Import this package to automatically set up app sandboxing on startup:
//
//        import (
//            _ "github.com/tmc/misc/macgo/auto/sandbox"
//        )
//
// This will automatically enable app sandboxing and create the app bundle.
// No user-selected file access is enabled by default. To include read-only
// file access, use github.com/tmc/misc/macgo/auto/sandbox/readonly.
package sandbox

import (
        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Only enable app sandbox for basic security
        macgo.RequestEntitlements(macgo.EntAppSandbox)
        // Start macgo
        macgo.Start()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package signalhandler provides automatic initialization for macgo with app sandboxing
// and improved signal handling using the Go tool's signal handling pattern.
//
// Import this package to automatically set up app sandboxing on startup with improved signal handling:
//
//        import (
//            _ "github.com/tmc/misc/macgo/auto/sandbox/signalhandler"
//        )
//
// This will automatically enable app sandboxing and create the app bundle with improved signal handling.
package signalhandler

import (
        "io"
        "os"
        "os/exec"
        "os/signal"
        "syscall"

        "github.com/tmc/misc/macgo"
        // Import sandbox for initialization, even though we don't use it directly
        _ "github.com/tmc/misc/macgo/auto/sandbox"
)

func init() <span class="cov0" title="0">{
        // Replace the default relaunch function with our improved one
        macgo.SetReLaunchFunction(improvedRelaunch)
}</span>

// Improved relaunch that uses the Go tool's signal handling pattern
// which is more robust than the previous approach
func improvedRelaunch(appPath, execPath string, args []string) <span class="cov0" title="0">{
        // Set environment to prevent relaunching again
        os.Setenv("MACGO_NO_RELAUNCH", "1")

        // Create pipes for IO redirection
        pipes := make([]string, 3)
        for i, name := range []string{"stdin", "stdout", "stderr"} </span><span class="cov0" title="0">{
                pipe, err := createPipe("macgo-" + name)
                if err != nil </span><span class="cov0" title="0">{
                        macgo.Debug("error creating %s pipe: %v", name, err)
                        return
                }</span>
                <span class="cov0" title="0">pipes[i] = pipe
                defer os.Remove(pipe)</span>
        }

        // We need to replace the args with our own, ignoring what was passed in
        // This ensures proper pipe IO redirection
        <span class="cov0" title="0">pipeArgs := []string{
                "-a", appPath,
                "--wait-apps",
                "--stdin", pipes[0],
                "--stdout", pipes[1],
                "--stderr", pipes[2],
        }

        // Pass original arguments
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                pipeArgs = append(pipeArgs, "--args")
                pipeArgs = append(pipeArgs, os.Args[1:]...)
        }</span>

        // Launch app bundle with more robust approach
        <span class="cov0" title="0">toolPath, err := exec.LookPath("open")
        if err != nil </span><span class="cov0" title="0">{
                macgo.Debug("error finding open command: %v", err)
                return
        }</span>

        <span class="cov0" title="0">toolCmd := &amp;exec.Cmd{
                Path: toolPath,
                Args: append([]string{toolPath}, pipeArgs...),
                SysProcAttr: &amp;syscall.SysProcAttr{
                        Setpgid: true,
                        Pgid:    0, // Use the parent's process group
                },
        }

        err = toolCmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                macgo.Debug("error starting app bundle: %v", err)
                return
        }</span>

        // Set up signal handling
        <span class="cov0" title="0">c := make(chan os.Signal, 100)
        signal.Notify(c)
        go func() </span><span class="cov0" title="0">{
                for sig := range c </span><span class="cov0" title="0">{
                        macgo.Debug("Forwarding signal %v to app bundle process group", sig)
                        // Forward to entire process group using negative PID
                        sigNum := sig.(syscall.Signal)

                        // Skip SIGCHLD as we don't need to forward it
                        if sigNum == syscall.SIGCHLD </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Using negative PID sends to the entire process group
                        <span class="cov0" title="0">if err := syscall.Kill(-toolCmd.Process.Pid, sigNum); err != nil </span><span class="cov0" title="0">{
                                macgo.Debug("Error forwarding signal %v: %v", sigNum, err)
                        }</span>

                        // Special handling for terminal signals
                        <span class="cov0" title="0">if sigNum == syscall.SIGTSTP || sigNum == syscall.SIGTTIN || sigNum == syscall.SIGTTOU </span><span class="cov0" title="0">{
                                // Use SIGSTOP for terminal signals
                                syscall.Kill(syscall.Getpid(), syscall.SIGSTOP)
                        }</span>
                }
        }()

        // Handle stdin
        <span class="cov0" title="0">go pipeIO(pipes[0], os.Stdin, nil)

        // Handle stdout
        go pipeIO(pipes[1], nil, os.Stdout)

        // Handle stderr
        go pipeIO(pipes[2], nil, os.Stderr)

        // Wait for process to finish
        err = toolCmd.Wait()

        // Clean up signal handling
        signal.Stop(c)
        close(c)

        if err != nil </span><span class="cov0" title="0">{
                // Only print about the exit status if the command
                // didn't even run or it didn't exit cleanly
                if e, ok := err.(*exec.ExitError); !ok || !e.Exited() </span><span class="cov0" title="0">{
                        macgo.Debug("error waiting for app bundle: %v", err)
                }</span>
                <span class="cov0" title="0">if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        os.Exit(exitErr.ExitCode())
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">os.Exit(0)</span>
}

// createPipe creates a named pipe.
func createPipe(prefix string) (string, error) <span class="cov0" title="0">{
        tmp, err := os.CreateTemp("", prefix+"-*")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">path := tmp.Name()
        tmp.Close()
        os.Remove(path)

        cmd := exec.Command("mkfifo", path)
        return path, cmd.Run()</span>
}

// pipeIO copies data between a pipe and stdin/stdout/stderr.
func pipeIO(pipe string, in io.Reader, out io.Writer) <span class="cov0" title="0">{
        mode := os.O_RDONLY
        if in != nil </span><span class="cov0" title="0">{
                mode = os.O_WRONLY
        }</span>

        <span class="cov0" title="0">f, err := os.OpenFile(pipe, mode, 0)
        if err != nil </span><span class="cov0" title="0">{
                macgo.Debug("error opening pipe: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()

        if in != nil </span><span class="cov0" title="0">{
                io.Copy(f, in)
        }</span> else<span class="cov0" title="0"> {
                io.Copy(out, f)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Command macgo-debug is a utility for debugging macgo applications
// It provides advanced debugging and monitoring capabilities for macgo processes
package main

import (
        "flag"
        "fmt"
        "net/http"
        "os"
        "os/exec"
        "os/signal"
        "strconv"
        "strings"
        "syscall"
        "time"
)

var (
        // Command-line flags
        flagPid       = flag.Int("pid", 0, "Target process ID")
        flagSignal    = flag.String("signal", "INT", "Signal to send (INT, TERM, etc)")
        flagMonitor   = flag.Bool("monitor", false, "Monitor the process")
        flagPprof     = flag.Bool("pprof", false, "Start pprof server for this process")
        flagPprofPort = flag.Int("pprof-port", 6060, "Port for pprof server")
        flagVerbose   = flag.Bool("verbose", false, "Enable verbose logging")
        flagTrace     = flag.Bool("trace", false, "Trace all signals")
        flagHelp      = flag.Bool("help", false, "Show help message")
)

func main() <span class="cov0" title="0">{
        // Parse command-line flags
        flag.Parse()

        // Show help message if requested
        if *flagHelp </span><span class="cov0" title="0">{
                showHelp()
                return
        }</span>

        // Start pprof server if requested
        <span class="cov0" title="0">if *flagPprof </span><span class="cov0" title="0">{
                go startPprofServer(*flagPprofPort)
        }</span>

        // Send signal to process if pid is provided
        <span class="cov0" title="0">if *flagPid &gt; 0 </span><span class="cov0" title="0">{
                if err := sendSignal(*flagPid, *flagSignal); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error sending signal: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        // Monitor process if requested
        <span class="cov0" title="0">if *flagMonitor &amp;&amp; *flagPid &gt; 0 </span><span class="cov0" title="0">{
                monitorProcess(*flagPid)
        }</span>
}

// showHelp displays usage information
func showHelp() <span class="cov0" title="0">{
        fmt.Println("macgo-debug: Advanced debugging utility for macgo applications")
        fmt.Println("")
        fmt.Println("Usage:")
        fmt.Println("  macgo-debug [options]")
        fmt.Println("")
        fmt.Println("Options:")
        flag.PrintDefaults()
        fmt.Println("")
        fmt.Println("Examples:")
        fmt.Println("  Send SIGINT to process:        macgo-debug --pid=1234 --signal=INT")
        fmt.Println("  Monitor process:               macgo-debug --pid=1234 --monitor")
        fmt.Println("  Start pprof server:            macgo-debug --pprof --pprof-port=6060")
        fmt.Println("")
        fmt.Println("Environment Variables:")
        fmt.Println("  MACGO_DEBUG=1                 Enable debug logging for macgo processes")
        fmt.Println("  MACGO_SIGNAL_DEBUG=1          Enable detailed signal tracing")
        fmt.Println("  MACGO_DEBUG_LEVEL=2           Set debug verbosity level (0-3)")
        fmt.Println("  MACGO_PPROF=1                 Enable pprof HTTP server in macgo processes")
        fmt.Println("  MACGO_PPROF_PORT=6060         Set base port for pprof HTTP server")
}</span>

// sendSignal sends a signal to the specified process
func sendSignal(pid int, signalName string) error <span class="cov0" title="0">{
        // Convert signal name to signal number
        sig, err := parseSignal(signalName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Print signal info
        <span class="cov0" title="0">fmt.Printf("Sending signal %s (%d) to process %d\n", signalName, sig, pid)

        // Send signal to process
        proc, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error finding process: %w", err)
        }</span>

        <span class="cov0" title="0">return proc.Signal(sig)</span>
}

// parseSignal converts a signal name to a signal number
func parseSignal(name string) (os.Signal, error) <span class="cov0" title="0">{
        // Remove SIG prefix if present
        name = strings.TrimPrefix(strings.ToUpper(name), "SIG")

        // Map signal names to signal numbers
        switch name </span>{
        case "INT":<span class="cov0" title="0">
                return syscall.SIGINT, nil</span>
        case "TERM":<span class="cov0" title="0">
                return syscall.SIGTERM, nil</span>
        case "KILL":<span class="cov0" title="0">
                return syscall.SIGKILL, nil</span>
        case "HUP":<span class="cov0" title="0">
                return syscall.SIGHUP, nil</span>
        case "USR1":<span class="cov0" title="0">
                return syscall.SIGUSR1, nil</span>
        case "USR2":<span class="cov0" title="0">
                return syscall.SIGUSR2, nil</span>
        case "QUIT":<span class="cov0" title="0">
                return syscall.SIGQUIT, nil</span>
        default:<span class="cov0" title="0">
                // Try to parse as a number
                if num, err := strconv.Atoi(name); err == nil </span><span class="cov0" title="0">{
                        return syscall.Signal(num), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unknown signal: %s", name)</span>
        }
}

// monitorProcess monitors a process and its children
func monitorProcess(pid int) <span class="cov0" title="0">{
        fmt.Printf("Monitoring process %d\n", pid)

        // Check if process exists
        if _, err := os.FindProcess(pid); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error finding process: %v\n", err)
                return
        }</span>

        // Set up signal handling for graceful exit
        <span class="cov0" title="0">sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        // Start monitoring loop
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if process is still running
                        if !isProcessRunning(pid) </span><span class="cov0" title="0">{
                                fmt.Printf("Process %d has exited\n", pid)
                                return
                        }</span>

                        // Print process information
                        <span class="cov0" title="0">if *flagVerbose </span><span class="cov0" title="0">{
                                printProcessInfo(pid)
                        }</span>

                case sig := &lt;-sigCh:<span class="cov0" title="0">
                        fmt.Printf("Received signal %v, stopping monitoring\n", sig)
                        return</span>
                }
        }
}

// isProcessRunning checks if a process is running
func isProcessRunning(pid int) bool <span class="cov0" title="0">{
        process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Send signal 0 to check if process exists
        <span class="cov0" title="0">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

// printProcessInfo prints information about a process
func printProcessInfo(pid int) <span class="cov0" title="0">{
        // Run ps command to get process info
        cmd := exec.Command("ps", "-o", "pid,ppid,pgid,%cpu,%mem,state,command", "-p", strconv.Itoa(pid))
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting process info: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(strings.TrimSpace(string(output)))</span>
}

// startPprofServer starts a pprof HTTP server
func startPprofServer(port int) <span class="cov0" title="0">{
        // Try multiple ports if the default one is in use
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                addr := fmt.Sprintf("localhost:%d", port)
                fmt.Printf("Starting pprof server on %s\n", addr)

                // Add custom handler for process info
                http.HandleFunc("/macgo/info", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "text/plain")
                        fmt.Fprintf(w, "macgo-debug utility\n")
                        fmt.Fprintf(w, "PID: %d\n", os.Getpid())
                        fmt.Fprintf(w, "Target PID: %d\n", *flagPid)
                        fmt.Fprintf(w, "Time: %s\n", time.Now().Format(time.RFC3339))
                }</span>)

                // Print usage info
                <span class="cov0" title="0">fmt.Printf("pprof endpoints available at:\n")
                fmt.Printf("  http://%s/debug/pprof/\n", addr)
                fmt.Printf("  Process info: http://%s/macgo/info\n", addr)

                err := http.ListenAndServe(addr, nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to start pprof server on port %d: %v\n", port, err)
                        // Try next port
                        port++
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package debug provides advanced debugging capabilities for macgo.
// It includes detailed signal handling logs and pprof support.
package debug

import (
        "fmt"
        "io"
        "log"
        "net/http"
        _ "net/http/pprof" // Import for side effects to register pprof handlers
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "sync"
        "syscall"
        "time"
)

var (
        // Debug flags
        signalDebugEnabled = false
        advancedDebugLevel = 0
        debugLogFile       *os.File
        debugLogger        *log.Logger
        defaultLogPath     = filepath.Join(os.TempDir(), "macgo-debug.log")
        pprofEnabled       = false
        defaultPprofPort   = 6060
        pprofPortIncrement = 1
        pprofBasePort      = defaultPprofPort
        debugMutex         sync.Mutex
        isInitialized      bool

        // TraceSignalHandling enables detailed tracing of all signal handling operations
        TraceSignalHandling = false
)

// initialize sets up the debug package
func initialize() <span class="cov0" title="0">{
        debugMutex.Lock()
        defer debugMutex.Unlock()

        if isInitialized </span><span class="cov0" title="0">{
                return
        }</span>

        // Check environment variables
        <span class="cov0" title="0">signalDebugEnabled = os.Getenv("MACGO_SIGNAL_DEBUG") == "1"

        // Parse advanced debug level
        if level, err := strconv.Atoi(os.Getenv("MACGO_DEBUG_LEVEL")); err == nil </span><span class="cov0" title="0">{
                advancedDebugLevel = level
        }</span>

        // Set up signal debugging if enabled
        <span class="cov0" title="0">if signalDebugEnabled </span><span class="cov0" title="0">{
                TraceSignalHandling = true

                // Get custom log path if provided
                logPath := os.Getenv("MACGO_DEBUG_LOG")
                if logPath == "" </span><span class="cov0" title="0">{
                        logPath = defaultLogPath
                }</span>

                // Set up debug log file
                <span class="cov0" title="0">var err error
                debugLogFile, err = os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: Failed to open debug log file: %v\n", err)
                        debugLogger = log.New(os.Stderr, "[macgo-debug] ", log.LstdFlags|log.Lmicroseconds)
                }</span> else<span class="cov0" title="0"> {
                        // Use multi-writer to write to both stderr and file
                        multiWriter := io.MultiWriter(os.Stderr, debugLogFile)
                        debugLogger = log.New(multiWriter, "[macgo-debug] ", log.LstdFlags|log.Lmicroseconds)
                }</span>

                <span class="cov0" title="0">logSystemInfo()</span>
        }

        // Check if pprof is enabled
        <span class="cov0" title="0">pprofEnabled = os.Getenv("MACGO_PPROF") == "1"
        if pprofEnabled </span><span class="cov0" title="0">{
                // Get custom base port if provided
                if port, err := strconv.Atoi(os.Getenv("MACGO_PPROF_PORT")); err == nil </span><span class="cov0" title="0">{
                        pprofBasePort = port
                }</span>

                // Start pprof server on this process
                <span class="cov0" title="0">go startPprofServer(pprofBasePort)</span>
        }

        <span class="cov0" title="0">isInitialized = true</span>
}

// Init ensures the debug package is initialized
func Init() <span class="cov0" title="0">{
        if !isInitialized </span><span class="cov0" title="0">{
                initialize()
        }</span>
}

// logSystemInfo logs basic system information for debugging
func logSystemInfo() <span class="cov0" title="0">{
        if debugLogger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">debugLogger.Printf("==== macgo debug logging initialized ====")
        debugLogger.Printf("PID: %d, PPID: %d", os.Getpid(), os.Getppid())
        debugLogger.Printf("Args: %v", os.Args)
        debugLogger.Printf("Signal debugging: enabled")
        debugLogger.Printf("Debug level: %d", advancedDebugLevel)
        debugLogger.Printf("OS: %s, Arch: %s", runtime.GOOS, runtime.GOARCH)

        // Get current working directory
        if cwd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                debugLogger.Printf("Working directory: %s", cwd)
        }</span>

        // Log some environment variables
        <span class="cov0" title="0">debugLogger.Printf("MACGO_DEBUG=%s", os.Getenv("MACGO_DEBUG"))
        debugLogger.Printf("MACGO_DEBUG_LEVEL=%s", os.Getenv("MACGO_DEBUG_LEVEL"))
        debugLogger.Printf("MACGO_SIGNAL_DEBUG=%s", os.Getenv("MACGO_SIGNAL_DEBUG"))
        debugLogger.Printf("MACGO_PPROF=%s", os.Getenv("MACGO_PPROF"))
        debugLogger.Printf("MACGO_PPROF_PORT=%s", os.Getenv("MACGO_PPROF_PORT"))

        // Log time
        debugLogger.Printf("Time: %s", time.Now().Format(time.RFC3339))
        debugLogger.Printf("=======================================")</span>
}

// LogSignal logs detailed information about a signal
func LogSignal(sig syscall.Signal, format string, args ...interface{}) <span class="cov0" title="0">{
        if !signalDebugEnabled || debugLogger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Format the message
        <span class="cov0" title="0">message := fmt.Sprintf(format, args...)

        // Create stack trace if debug level is high enough
        var stack string
        if advancedDebugLevel &gt;= 2 </span><span class="cov0" title="0">{
                buf := make([]byte, 4096)
                n := runtime.Stack(buf, false)
                stack = string(buf[:n])
        }</span>

        // Log the message
        <span class="cov0" title="0">debugLogger.Printf("SIGNAL %v: %s", sig, message)
        if advancedDebugLevel &gt;= 2 </span><span class="cov0" title="0">{
                debugLogger.Printf("Stack trace:\n%s", stack)
        }</span>
}

// LogDebug logs a debug message if signal debugging is enabled
func LogDebug(format string, args ...interface{}) <span class="cov0" title="0">{
        if !signalDebugEnabled || debugLogger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">debugLogger.Printf(format, args...)</span>
}

// startPprofServer starts a pprof HTTP server on the specified port
func startPprofServer(port int) <span class="cov0" title="0">{
        // Increment port for each new server
        actualPort := port

        // Start the server in a separate goroutine
        go func() </span><span class="cov0" title="0">{
                // Try multiple ports if the default one is in use
                for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                        addr := fmt.Sprintf("localhost:%d", actualPort)
                        server := &amp;http.Server{
                                Addr:    addr,
                                Handler: http.DefaultServeMux,
                        }

                        // Try to start the server
                        if signalDebugEnabled &amp;&amp; debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("Starting pprof server on %s", addr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "[macgo-pprof] Starting server on %s\n", addr)
                        }</span>

                        // Set up basic pprof info handler
                        <span class="cov0" title="0">http.HandleFunc("/macgo/info", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                info := fmt.Sprintf(`
Process Information:
  PID: %d
  PPID: %d
  Command: %s
  Args: %v
  Working Directory: %s
  Timestamp: %s
  
Environment:
  MACGO_DEBUG=%s
  MACGO_DEBUG_LEVEL=%s
  MACGO_SIGNAL_DEBUG=%s
  MACGO_PPROF=%s
  MACGO_PPROF_PORT=%s
`,
                                        os.Getpid(),
                                        os.Getppid(),
                                        os.Args[0],
                                        os.Args,
                                        getWorkingDir(),
                                        time.Now().Format(time.RFC3339),
                                        os.Getenv("MACGO_DEBUG"),
                                        os.Getenv("MACGO_DEBUG_LEVEL"),
                                        os.Getenv("MACGO_SIGNAL_DEBUG"),
                                        os.Getenv("MACGO_PPROF"),
                                        os.Getenv("MACGO_PPROF_PORT"),
                                )

                                w.Header().Set("Content-Type", "text/plain")
                                w.Write([]byte(info))
                        }</span>)

                        // Print usage information to make it easier for users
                        <span class="cov0" title="0">if signalDebugEnabled &amp;&amp; debugLogger != nil </span><span class="cov0" title="0">{
                                debugLogger.Printf("pprof endpoints available at:")
                                debugLogger.Printf("  http://%s/debug/pprof/", addr)
                                debugLogger.Printf("  Process info: http://%s/macgo/info", addr)
                                debugLogger.Printf("  Heap profile: http://%s/debug/pprof/heap", addr)
                                debugLogger.Printf("  CPU profile: http://%s/debug/pprof/profile", addr)
                                debugLogger.Printf("  Goroutine trace: http://%s/debug/pprof/trace", addr)
                                debugLogger.Printf("  Goroutine block profile: http://%s/debug/pprof/block", addr)
                                debugLogger.Printf("  Goroutine stack traces: http://%s/debug/pprof/goroutine", addr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "[macgo-pprof] Server available at http://%s/debug/pprof/\n", addr)
                                fmt.Fprintf(os.Stderr, "[macgo-pprof] Process info: http://%s/macgo/info\n", addr)
                        }</span>

                        <span class="cov0" title="0">err := server.ListenAndServe()
                        if err != nil </span><span class="cov0" title="0">{
                                if signalDebugEnabled &amp;&amp; debugLogger != nil </span><span class="cov0" title="0">{
                                        debugLogger.Printf("Failed to start pprof server on port %d: %v", actualPort, err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Fprintf(os.Stderr, "[macgo-pprof] Failed to start server on port %d: %v\n", actualPort, err)
                                }</span>
                                // Try next port
                                <span class="cov0" title="0">actualPort += pprofPortIncrement
                                continue</span>
                        }

                        <span class="cov0" title="0">break</span>
                }
        }()
}

// getWorkingDir returns the current working directory or an error message
func getWorkingDir() string <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error getting working directory: %v", err)
        }</span>
        <span class="cov0" title="0">return dir</span>
}

// GetNextPprofPort returns the next available pprof port for child processes
func GetNextPprofPort() int <span class="cov0" title="0">{
        debugMutex.Lock()
        defer debugMutex.Unlock()

        pprofBasePort += pprofPortIncrement
        return pprofBasePort
}</span>

// IsPprofEnabled returns true if pprof debugging is enabled
func IsPprofEnabled() bool <span class="cov0" title="0">{
        return pprofEnabled
}</span>

// IsTraceEnabled returns true if trace debugging is enabled
func IsTraceEnabled() bool <span class="cov0" title="0">{
        return TraceSignalHandling
}</span>

// Close cleans up debug resources
func Close() <span class="cov0" title="0">{
        debugMutex.Lock()
        defer debugMutex.Unlock()

        if debugLogFile != nil </span><span class="cov0" title="0">{
                debugLogFile.Close()
                debugLogFile = nil
        }</span>

        <span class="cov0" title="0">debugLogger = nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package calendar provides calendar access entitlement for macOS apps.
// Import this package with the blank identifier to enable calendar access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/calendar"
package calendar

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntCalendars, true)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package camera provides camera access entitlement for macOS apps.
// Import this package with the blank identifier to enable camera access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/camera"
package camera

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntCamera, true)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package contacts provides contacts/addressbook access entitlement for macOS apps.
// Import this package with the blank identifier to enable contacts access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/contacts"
package contacts

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntAddressBook, true)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package entitlements provides macOS entitlements for app sandbox and TCC permissions.
// This package centralizes all entitlement-related functionality for the macgo library.
package entitlements

import (
        "io"
        "os"

        "github.com/tmc/misc/macgo"
)

// Entitlement types from the main macgo package
type Entitlement = macgo.Entitlement

// Entitlement constants from the main macgo package
const (
        // App Sandbox entitlements
        EntAppSandbox    = macgo.EntAppSandbox
        EntNetworkClient = macgo.EntNetworkClient
        EntNetworkServer = macgo.EntNetworkServer

        // Device entitlements
        EntCamera     = macgo.EntCamera
        EntMicrophone = macgo.EntMicrophone
        EntBluetooth  = macgo.EntBluetooth
        EntUSB        = macgo.EntUSB
        EntAudioInput = macgo.EntAudioInput
        EntPrint      = macgo.EntPrint

        // Personal information entitlements
        EntAddressBook = macgo.EntAddressBook
        EntLocation    = macgo.EntLocation
        EntCalendars   = macgo.EntCalendars
        EntPhotos      = macgo.EntPhotos
        EntReminders   = macgo.EntReminders // Updated to use consistent naming

        // File entitlements
        EntUserSelectedReadOnly  = macgo.EntUserSelectedReadOnly
        EntUserSelectedReadWrite = macgo.EntUserSelectedReadWrite
        EntDownloadsReadOnly     = macgo.EntDownloadsReadOnly
        EntDownloadsReadWrite    = macgo.EntDownloadsReadWrite
        EntPicturesReadOnly      = macgo.EntPicturesReadOnly
        EntPicturesReadWrite     = macgo.EntPicturesReadWrite
        EntMusicReadOnly         = macgo.EntMusicReadOnly
        EntMusicReadWrite        = macgo.EntMusicReadWrite
        EntMoviesReadOnly        = macgo.EntMoviesReadOnly
        EntMoviesReadWrite       = macgo.EntMoviesReadWrite

        // Hardened Runtime entitlements
        EntAllowJIT                        = macgo.EntAllowJIT
        EntAllowUnsignedExecutableMemory   = macgo.EntAllowUnsignedExecutableMemory
        EntAllowDyldEnvVars                = macgo.EntAllowDyldEnvVars
        EntDisableLibraryValidation        = macgo.EntDisableLibraryValidation
        EntDisableExecutablePageProtection = macgo.EntDisableExecutablePageProtection
        EntDebugger                        = macgo.EntDebugger

        // Virtualization entitlements
        EntVirtualization = macgo.EntVirtualization
)

// Register registers an entitlement with the macgo system
func Register(ent Entitlement, value bool) <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                macgo.RequestEntitlement(ent)
        }</span>
}

// TCC Permission functions

// SetCamera enables camera access
func SetCamera() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntCamera)
}</span>

// SetMic enables microphone access
func SetMic() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntMicrophone)
}</span>

// SetLocation enables location access
func SetLocation() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntLocation)
}</span>

// SetContacts enables contacts access
func SetContacts() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntAddressBook)
}</span>

// SetPhotos enables photos library access
func SetPhotos() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntPhotos)
}</span>

// SetCalendar enables calendar access
func SetCalendar() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntCalendars)
}</span>

// SetReminders enables reminders access
func SetReminders() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntReminders)
}</span>

// App Sandbox functions

// SetAppSandbox enables App Sandbox
func SetAppSandbox() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntAppSandbox)
}</span>

// SetNetworkClient enables outgoing network connections
// NOTE: This only affects Objective-C/Swift network APIs. Go's standard networking
// (net/http, etc.) bypasses these restrictions and will work regardless of this
// entitlement being present or not.
func SetNetworkClient() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntNetworkClient)
}</span>

// SetNetworkServer enables incoming network connections
// NOTE: This only affects Objective-C/Swift network APIs. Go's standard networking
// (net.Listen, etc.) bypasses these restrictions and will work regardless of this
// entitlement being present or not.
func SetNetworkServer() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntNetworkServer)
}</span>

// Device access functions

// SetBluetooth enables Bluetooth access
func SetBluetooth() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntBluetooth)
}</span>

// SetUSB enables USB device access
func SetUSB() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntUSB)
}</span>

// SetAudioInput enables audio input access
func SetAudioInput() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntAudioInput)
}</span>

// SetPrinting enables printing capabilities
func SetPrinting() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntPrint)
}</span>

// Hardened Runtime functions

// SetAllowJIT enables JIT compilation
func SetAllowJIT() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntAllowJIT)
}</span>

// SetAllowUnsignedMemory allows unsigned executable memory
func SetAllowUnsignedMemory() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntAllowUnsignedExecutableMemory)
}</span>

// SetAllowDyldEnvVars allows DYLD environment variables
func SetAllowDyldEnvVars() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntAllowDyldEnvVars)
}</span>

// SetDisableLibraryValidation disables library validation
func SetDisableLibraryValidation() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntDisableLibraryValidation)
}</span>

// SetDisableExecutablePageProtection disables executable memory page protection
func SetDisableExecutablePageProtection() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntDisableExecutablePageProtection)
}</span>

// SetDebugger enables attaching to other processes as a debugger
func SetDebugger() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntDebugger)
}</span>

// SetVirtualization enables virtualization support
func SetVirtualization() <span class="cov8" title="1">{
        macgo.RequestEntitlement(EntVirtualization)
}</span>

// SetCustomEntitlement enables any arbitrary entitlement by its key string
func SetCustomEntitlement(key string, value bool) <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                macgo.RequestEntitlement(key)
        }</span>
}

// RegisterEntitlements registers entitlements directly from a JSON byte array
func RegisterEntitlements(data []byte) error <span class="cov8" title="1">{
        return macgo.LoadEntitlementsFromJSON(data)
}</span>

// RegisterEntitlementsFromReader loads entitlements from a JSON reader and registers them
func RegisterEntitlementsFromReader(r io.Reader) error <span class="cov8" title="1">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return RegisterEntitlements(data)</span>
}

// RegisterEntitlementsFromFile loads entitlements from a JSON file and registers them
func RegisterEntitlementsFromFile(path string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return RegisterEntitlements(data)</span>
}

// Convenience functions

// SetAllTCCPermissions enables all TCC permissions
func SetAllTCCPermissions() <span class="cov8" title="1">{
        SetCamera()
        SetMic()
        SetLocation()
        SetContacts()
        SetPhotos()
        SetCalendar()
        SetReminders()
}</span>

// SetAllDeviceAccess enables all device access permissions
func SetAllDeviceAccess() <span class="cov8" title="1">{
        SetCamera()
        SetMic()
        SetBluetooth()
        SetUSB()
        SetAudioInput()
        SetPrinting()
}</span>

// SetAllNetworking enables all networking permissions
func SetAllNetworking() <span class="cov8" title="1">{
        SetNetworkClient()
        SetNetworkServer()
}</span>

// SetAll enables all basic TCC permissions
func SetAll() <span class="cov8" title="1">{
        SetAllTCCPermissions()
}</span>

// RequestEntitlements requests multiple entitlements at once
func RequestEntitlements(entitlements ...interface{}) <span class="cov8" title="1">{
        macgo.RequestEntitlements(entitlements...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package location provides location access entitlement for macOS apps.
// Import this package with the blank identifier to enable location access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/location"
package location

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntLocation, true)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package mic provides microphone access entitlement for macOS apps.
// Import this package with the blank identifier to enable microphone access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/mic"
package mic

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntMicrophone, true)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package photos provides photos library access entitlement for macOS apps.
// Import this package with the blank identifier to enable photos access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/photos"
package photos

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntPhotos, true)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package reminders provides reminders access entitlement for macOS apps.
// Import this package with the blank identifier to enable reminders access:
//
//        import _ "github.com/tmc/misc/macgo/entitlements/reminders"
package reminders

import "github.com/tmc/misc/macgo/entitlements"

func init() <span class="cov8" title="1">{
        entitlements.Register(entitlements.EntReminders, true)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Advanced configuration example using the Config API and improved signal handling
package main

import (
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // No need to disable auto-initialization as it's disabled by default

        // Create a custom configuration
        cfg := macgo.NewConfig()

        // Set application details
        cfg.ApplicationName = "AdvancedExampleApp"
        cfg.BundleID = "com.example.macgo.advanced"

        // Add entitlements individually
        cfg.AddEntitlement(macgo.EntCamera)
        cfg.AddEntitlement(macgo.EntMicrophone)

        // Request multiple entitlements at once
        cfg.RequestEntitlements(
                macgo.EntLocation,
        )

        // Access to user-selected files (already enabled by default)
        cfg.AddEntitlement(macgo.EntUserSelectedReadOnly)

        // Make this a proper GUI application to control dock behavior
        cfg.AddPlistEntry("LSUIElement", false) // Show in dock

        // Add NSHighResolutionCapable for proper Retina support
        cfg.AddPlistEntry("NSHighResolutionCapable", true)

        // Override app name in dock
        cfg.AddPlistEntry("CFBundleDisplayName", "Advanced macgo Example")

        // Control app bundle behavior
        cfg.Relaunch = true  // Auto-relaunch (default)
        cfg.AutoSign = true  // Auto-sign the bundle (default)
        cfg.KeepTemp = false // Don't keep temporary bundles

        // Apply configuration (must be called)
        macgo.Configure(cfg)

        // Enable debug logging (optional)
        macgo.EnableDebug()
        // Start the application
        macgo.Start()
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("macgo Advanced Configuration Example with Signal Handling")
        fmt.Println("-------------------------------------------------------")
        fmt.Println("This example showcases the Config API and improved signal handling.")
        fmt.Println("Try pressing Ctrl+C to see proper signal handling in action.")
        fmt.Println()

        // Set up signal handling for demonstration
        c := make(chan os.Signal, 1)
        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)

        // Print which entitlements are likely enabled
        fmt.Println("Enabled entitlements:")
        fmt.Println("- Camera access")
        fmt.Println("- Microphone access")
        fmt.Println("- User-selected files (read-only)")
        fmt.Println()

        // Show that we can access the Desktop (through user-selected files)
        homeDir, _ := os.UserHomeDir()
        fmt.Printf("Reading Desktop directory: %s/Desktop\n", homeDir)

        files, err := os.ReadDir(homeDir + "/Desktop")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d files\n", len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        fmt.Println("...")
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("- %s\n", file.Name())</span>
        }

        // Runtime information
        <span class="cov0" title="0">fmt.Println("\nRuntime information:")
        fmt.Println("- This process is either:")
        fmt.Println("  1. The first run: Setting up the app bundle")
        fmt.Println("  2. Running inside the bundle: UI settings are active")

        fmt.Printf("- Currently running in app bundle: %v\n", macgo.IsInAppBundle())
        fmt.Println("- If in bundle: App will show in dock with NO bouncing")
        fmt.Println("  (Using Objective-C to control dock behavior)")

        // Wait for user input
        fmt.Println("\nPress Enter to exit")
        var input string
        fmt.Scanln(&amp;input)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Example demonstrating custom app template with go:embed and auto-signing
package main

import (
        "embed"
        "fmt"
        "os"

        "github.com/tmc/misc/macgo"
)

// Embed the entire app template directory
//
//go:embed app-template
var appTemplate embed.FS

func init() <span class="cov0" title="0">{
        // Method 1: Using the simplified API for the custom template
        macgo.SetCustomAppBundle(appTemplate)

        // Set application details
        macgo.SetAppName("CustomTemplateApp")
        macgo.SetBundleID("com.example.macgo.custom-template")

        // Enable auto-signing (commented out for example purposes)
        // macgo.EnableSigning("") // Use default identity
        // macgo.EnableSigning("Developer ID Application: Your Name (XXXXXXXXXX)") // Specific identity

        // Add entitlements
        macgo.RequestEntitlements(
                macgo.EntCamera,
                macgo.EntMicrophone,
                "com.apple.security.automation.apple-events",
        )

        // Method 2: Using the Config API for more complex scenarios
        // Uncomment to use this approach instead
        /*
                cfg := macgo.NewConfig()
                cfg.ApplicationName = "CustomTemplateApp"
                cfg.BundleID = "com.example.macgo.custom-template"
                cfg.AppTemplate = appTemplate
                cfg.AutoSign = true
                cfg.Entitlements = macgo.Entitlements{
                        macgo.EntCamera:     true,
                        macgo.EntMicrophone: true,
                }
                macgo.Configure(cfg)
        */
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("MacGo Custom Template Example")
        fmt.Println("This app demonstrates:")
        fmt.Println("1. Using a custom app template with go:embed")
        fmt.Println("2. Auto-signing capability (commented out by default)")
        fmt.Println("3. Combined with entitlements configuration")
        fmt.Println()
        fmt.Println("The app template includes:")
        fmt.Println("- Templated Info.plist with placeholder variables")
        fmt.Println("- Pre-configured entitlements for network and virtualization")
        fmt.Println("- Placeholder for executable injection")

        // Try to read desktop files
        homeDir, _ := os.UserHomeDir()
        fmt.Printf("\nReading %s/Desktop: ", homeDir)

        files, err := os.ReadDir(homeDir + "/Desktop")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Found %d files\n", len(files))
                for i, f := range files </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                fmt.Println("...")
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("- %s\n", f.Name())</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// This example shows how to customize app behavior with environment variables.
package main

import (
        "fmt"
        "os"

        // Blank import of macgo auto for environment variable configuration
        _ "github.com/tmc/misc/macgo/auto" // --
)

// This example doesn't need init() as everything is configured
// through environment variables:
//
// Run with:
// MACGO_APP_NAME="CustomApp" MACGO_BUNDLE_ID="com.example.custom" MACGO_CAMERA=1 MACGO_MIC=1 MACGO_DEBUG=1 go run main.go

func main() <span class="cov0" title="0">{
        fmt.Println("macgo Environment Variables Example")
        fmt.Println("This app is configured entirely with environment variables")
        fmt.Println("Run with: MACGO_APP_NAME=\"CustomApp\" MACGO_BUNDLE_ID=\"com.example.custom\" MACGO_CAMERA=1 MACGO_MIC=1 MACGO_DEBUG=1 go run main.go")
        fmt.Println()

        // Show environment variable configuration
        printEnvConfig("MACGO_APP_NAME")
        printEnvConfig("MACGO_BUNDLE_ID")
        printEnvConfig("MACGO_DEBUG")

        // TCC Permission environment variables
        fmt.Println("\nTCC Permission Variables:")
        printEnvConfig("MACGO_CAMERA")
        printEnvConfig("MACGO_MIC")
        printEnvConfig("MACGO_PHOTOS")
        printEnvConfig("MACGO_LOCATION")
        printEnvConfig("MACGO_CONTACTS")
        printEnvConfig("MACGO_CALENDAR")
        printEnvConfig("MACGO_REMINDERS")

        // Advanced configuration variables
        fmt.Println("\nAdvanced Configuration Variables:")
        printEnvConfig("MACGO_KEEP_TEMP")
        printEnvConfig("MACGO_NO_RELAUNCH")
        printEnvConfig("MACGO_APP_PATH")
        printEnvConfig("MACGO_SIGN")
        printEnvConfig("MACGO_SIGN_IDENTITY")

        homeDir, _ := os.UserHomeDir()
        fmt.Printf("\nReading Desktop directory: %s/Desktop\n", homeDir)

        files, err := os.ReadDir(homeDir + "/Desktop")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d files\n", len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        fmt.Println("...")
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("- %s\n", file.Name())</span>
        }
}

func printEnvConfig(name string) <span class="cov0" title="0">{
        value := os.Getenv(name)
        if value != "" </span><span class="cov0" title="0">{
                fmt.Printf("%s = %s\n", name, value)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%s not set\n", name)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Debug Features Example
// This example demonstrates how to use the advanced debugging features in macgo
package main

import (
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Set up basic configuration
        macgo.SetAppName("DebugFeaturesApp")
        macgo.SetBundleID("com.example.macgo.debugfeatures")

        // Enable improved signal handling with IO redirection
        macgo.EnableImprovedSignalHandling()

        // Enable debug output to see what's happening
        macgo.EnableDebug()

        // Demonstrate how to enable advanced debug features through environment variables
        // In a real application, these would be set before running the program
        // MACGO_SIGNAL_DEBUG=1 MACGO_PPROF=1 MACGO_DEBUG_LEVEL=2 go run ./examples/debug-features/main.go

        // For this example, we'll check and explain the environment variables
        fmt.Println("Debug Environment Variables:")
        fmt.Printf("  MACGO_DEBUG=%s (Basic debug logging)\n", getEnvOrDefault("MACGO_DEBUG", "0"))
        fmt.Printf("  MACGO_SIGNAL_DEBUG=%s (Detailed signal tracing)\n", getEnvOrDefault("MACGO_SIGNAL_DEBUG", "0"))
        fmt.Printf("  MACGO_DEBUG_LEVEL=%s (Debug verbosity level)\n", getEnvOrDefault("MACGO_DEBUG_LEVEL", "0"))
        fmt.Printf("  MACGO_PPROF=%s (Enable pprof HTTP server)\n", getEnvOrDefault("MACGO_PPROF", "0"))
        fmt.Printf("  MACGO_PPROF_PORT=%s (Base port for pprof server)\n", getEnvOrDefault("MACGO_PPROF_PORT", "6060"))
        fmt.Println()

        // Print debugging instructions
        fmt.Println("To run with debugging enabled:")
        fmt.Println("  MACGO_DEBUG=1 MACGO_SIGNAL_DEBUG=1 MACGO_PPROF=1 go run ./examples/debug-features/main.go")
        fmt.Println()

        // Print how to use the macgo-debug utility
        fmt.Println("To debug with macgo-debug utility:")
        fmt.Println("  1. Run this example with MACGO_DEBUG=1")
        fmt.Println("  2. In another terminal, run: go run ./cmd/macgo-debug/main.go --help")
        fmt.Println("  3. To monitor: go run ./cmd/macgo-debug/main.go --pid=&lt;pid&gt; --monitor")
        fmt.Println("  4. To send signals: go run ./cmd/macgo-debug/main.go --pid=&lt;pid&gt; --signal=INT")
        fmt.Println()
}</span>

func main() <span class="cov0" title="0">{
        // Start macgo - this creates the app bundle and relaunches if needed
        macgo.Start()

        fmt.Println("Debug Features Example")
        fmt.Println("=====================")
        fmt.Printf("Process ID: %d\n", os.Getpid())

        if os.Getenv("MACGO_PPROF") == "1" </span><span class="cov0" title="0">{
                port := os.Getenv("MACGO_PPROF_PORT")
                if port == "" </span><span class="cov0" title="0">{
                        port = "6060"
                }</span>
                <span class="cov0" title="0">fmt.Printf("pprof server running at: http://localhost:%s/debug/pprof/\n", port)
                fmt.Printf("Process info: http://localhost:%s/macgo/info\n", port)</span>
        }

        <span class="cov0" title="0">fmt.Println("Press Ctrl+C to test signal handling")
        fmt.Println()

        // Set up a channel to listen for signals
        c := make(chan os.Signal, 1)
        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)

        // Display a countdown
        go func() </span><span class="cov0" title="0">{
                for i := 60; i &gt; 0; i-- </span><span class="cov0" title="0">{
                        fmt.Printf("\rWaiting... %d seconds remaining", i)
                        time.Sleep(1 * time.Second)
                }</span>
                <span class="cov0" title="0">fmt.Println("\rTimeout reached, exiting normally        ")</span>
        }()

        // Wait for a signal or timeout
        <span class="cov0" title="0">sig := &lt;-c
        fmt.Printf("\n\nReceived signal: %v\n", sig)
        fmt.Println("Exiting gracefully")</span>
}

// getEnvOrDefault returns the value of an environment variable or a default value
func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Using go:embed with the LoadEntitlementsFromJSON API
// Run with: MACGO_DEBUG=1 go run main.go
package main

import (
        "embed"
        "fmt"
        "log"
        "os"

        // Import the macgo package directly
        "github.com/tmc/misc/macgo"
)

// Define custom entitlements in a JSON file and embed it
//
//go:embed entitlements.json
var entitlementsData []byte

// Embed using the embed.FS type for multiple files
//
//go:embed *.json
var entitlementsFS embed.FS

func init() <span class="cov0" title="0">{
        // This example focuses on using go:embed with entitlements configuration

        // Use the LoadEntitlementsFromJSON API to load the embedded data
        fmt.Println("Loading entitlements from embedded JSON data")
        if err := macgo.LoadEntitlementsFromJSON(entitlementsData); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load entitlements: %v", err)
        }</span>

        // Additional configuration
        <span class="cov0" title="0">macgo.SetAppName("MacGoEmbed")
        macgo.SetBundleID("com.example.macgo.embed")
        macgo.EnableDebug()</span> // Enable debug output
}

func main() <span class="cov0" title="0">{
        fmt.Println("\nMacGo go:embed Example")
        fmt.Println("This example demonstrates how to use go:embed with macgo")
        fmt.Println("The key benefits of this approach:")
        fmt.Println("- Keep entitlements configuration in a separate JSON file")
        fmt.Println("- Embed the configuration directly in the binary")
        fmt.Println("- No code changes needed to update entitlements")
        fmt.Println("- Configuration can be selected at build time")
        fmt.Println()

        // Show what permissions are likely configured
        fmt.Println("Entitlements from JSON typically include:")
        fmt.Println("- App Sandbox")
        fmt.Println("- Network client/server")
        fmt.Println("- Camera and microphone access")
        fmt.Println("- Location and photos access")
        fmt.Println()

        // Try to read some directories
        home, _ := os.UserHomeDir()
        dirs := []string{
                home + "/Desktop",
                home + "/Pictures",
                home + "/Documents",
        }

        for _, dir := range dirs </span><span class="cov0" title="0">{
                fmt.Printf("Reading %s: ", dir)

                files, err := os.ReadDir(dir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("error: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("%d files\n", len(files))
                // Show first few files
                for i, f := range files </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                fmt.Println("...")
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("- %s\n", f.Name())</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "fmt"
        "os"
        "time"

        "github.com/tmc/misc/macgo"
        "github.com/tmc/misc/macgo/debug" // Using the dedicated debug package
)

func init() <span class="cov0" title="0">{
        // Initialize macgo's debug package early.
        // This reads env vars like MACGO_SIGNAL_DEBUG, MACGO_PPROF.
        debug.Init()

        // Enable macgo's internal debug logging (MACGO_DEBUG=1)
        macgo.EnableDebug()

        // Configure macgo (optional, defaults will be used if not set)
        macgo.SetAppName("HelloMacgoApp")
        macgo.SetBundleID("com.example.hellomacgo")
        // macgo.RequestEntitlements(macgo.EntCamera) // Example: if camera needed

        // Start macgo - creates bundle and relaunches if necessary
        macgo.Start()
}</span>

func main() <span class="cov0" title="0">{
        fmt.Printf("Hello from macgo! PID: %d\n", os.Getpid())
        fmt.Printf("Running in app bundle: %t\n", macgo.IsInAppBundle())

        if os.Getenv("MACGO_DEBUG") == "1" </span><span class="cov0" title="0">{
                fmt.Println("macgo internal debug logging is enabled.")
        }</span>
        <span class="cov0" title="0">if debug.IsTraceEnabled() </span><span class="cov0" title="0">{
                fmt.Println("macgo.debug signal tracing is enabled (check logs).")
        }</span>
        <span class="cov0" title="0">if debug.IsPprofEnabled() </span><span class="cov0" title="0">{
                fmt.Println("macgo.debug pprof server for this app is enabled (check logs for port).")
        }</span>

        <span class="cov0" title="0">fmt.Println("Application will run for 3 seconds then exit.")
        time.Sleep(3 * time.Second)

        fmt.Println("Exiting HelloMacgoApp.")
        // Clean up debug package resources if it was used for logging to file
        debug.Close()</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Legacy Signal Handling Example
// This example demonstrates how to opt out of the default robust signal handling
package main

import (
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Set up basic configuration
        macgo.SetAppName("LegacySignalsApp")
        macgo.SetBundleID("com.example.macgo.legacysignals")

        // Disable the robust signal handling
        // This is rarely needed, but demonstrates how to opt out
        macgo.DisableRobustSignals()

        // Enable debug output to see what's happening
        macgo.EnableDebug()
}</span>

func main() <span class="cov0" title="0">{
        // Start macgo - this creates the app bundle and relaunches if needed
        // Legacy signal handling will be used due to DisableRobustSignals()
        macgo.Start()

        fmt.Println("Legacy Signal Handling Test")
        fmt.Println("==========================")
        fmt.Println("Press Ctrl+C to test signal handling")
        fmt.Println("Using legacy signal handling by request")
        fmt.Println()

        // Set up a channel to listen for signals
        c := make(chan os.Signal, 1)
        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)

        // Display a countdown
        go func() </span><span class="cov0" title="0">{
                for i := 30; i &gt; 0; i-- </span><span class="cov0" title="0">{
                        fmt.Printf("\rWaiting... %d seconds remaining", i)
                        time.Sleep(1 * time.Second)
                }</span>
                <span class="cov0" title="0">fmt.Println("\rTimeout reached, exiting normally        ")</span>
        }()

        // Wait for a signal or timeout
        <span class="cov0" title="0">sig := &lt;-c
        fmt.Printf("\n\nReceived signal: %v\n", sig)
        fmt.Println("Exiting gracefully")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// This is a test utility meant to be run as a child process by macgo's relaunch mechanism.
// It logs its state to a file for inspection during tests or debugging.
package main

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/tmc/misc/macgo"
        "github.com/tmc/misc/macgo/debug"
)

func init() <span class="cov0" title="0">{
        // Initialize debug package early (reads env vars)
        debug.Init()

        // Enable macgo's internal debug logs if MACGO_DEBUG is set
        if os.Getenv("MACGO_DEBUG") == "1" </span><span class="cov0" title="0">{
                macgo.EnableDebug()
        }</span>
        // No macgo.Start() here, as this is intended to BE the child process.
        // If this were a standalone app that *uses* macgo, Start() would be here.
}

func main() <span class="cov0" title="0">{
        logFileName := fmt.Sprintf("macgo-child-process-test-pid%d.log", os.Getpid())
        logFilePath := filepath.Join(os.TempDir(), logFileName)

        logFile, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to stderr if log file fails
                fmt.Fprintf(os.Stderr, "CHILD_ERROR: Failed to create log file %s: %v\n", logFilePath, err)
                logFile = os.Stderr // Log to stderr as a fallback
        }</span> else<span class="cov0" title="0"> {
                defer logFile.Close()
                fmt.Fprintf(os.Stdout, "CHILD_INFO: Logging to %s\n", logFilePath) // Also to stdout for visibility
        }</span>

        <span class="cov0" title="0">logMsg := func(format string, args ...interface{}) </span><span class="cov0" title="0">{
                fmt.Fprintf(logFile, "[%s] CHILD_LOG: ", time.Now().Format("15:04:05.000"))
                fmt.Fprintf(logFile, format, args...)
                fmt.Fprint(logFile, "\n")
                logFile.Sync() // Ensure logs are written immediately
        }</span>

        <span class="cov0" title="0">logMsg("=== MACGO CHILD PROCESS STARTED ===")
        logMsg("PID: %d, PPID: %d", os.Getpid(), os.Getppid())
        logMsg("In app bundle: %t (determined by macgo.IsInAppBundle)", macgo.IsInAppBundle())
        logMsg("Args: %v", os.Args)
        logMsg("--- Environment Variables ---")
        for _, envVar := range []string{"MACGO_DEBUG", "MACGO_NO_RELAUNCH", "MACGO_APP_NAME", "MACGO_BUNDLE_ID", "MACGO_PPROF_PORT"} </span><span class="cov0" title="0">{
                logMsg("  %s: %s", envVar, os.Getenv(envVar))
        }</span>
        <span class="cov0" title="0">logMsg("---------------------------")

        if wd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                logMsg("Working dir: %s", wd)
        }</span> else<span class="cov0" title="0"> {
                logMsg("Error getting working dir: %v", err)
        }</span>

        // Also try stdout/stderr for direct capture by parent if pipes are working
        <span class="cov0" title="0">fmt.Fprintf(os.Stdout, "CHILD_STDOUT: Child process is running! PID: %d\n", os.Getpid())
        fmt.Fprintf(os.Stderr, "CHILD_STDERR: Child process is running! PID: %d\n", os.Getpid())

        logMsg("Simulating work for 2 seconds...")
        time.Sleep(2 * time.Second)

        logMsg("=== MACGO CHILD PROCESS ENDING ===")
        fmt.Fprintf(os.Stdout, "CHILD_STDOUT: Child process ending. PID: %d\n", os.Getpid())
        fmt.Fprintf(os.Stderr, "CHILD_STDERR: Child process ending. PID: %d\n", os.Getpid())

        // Clean up debug package resources if it was used for logging to file
        debug.Close()</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// This example shows the minimal usage of macgo with blank imports.
package main

import (
        "fmt"
        "os"

        // Core functionality with blank import (uses environment variables for configuration)
        _ "github.com/tmc/misc/macgo/auto" // --
)

// Run with:
// MACGO_APP_NAME="MinimalApp" MACGO_CAMERA=1 go run main.go

func main() <span class="cov0" title="0">{
        fmt.Println("macgo minimal example")
        fmt.Println("This app has permissions via environment variables and blank import")
        fmt.Println("Run with: MACGO_APP_NAME=\"MinimalApp\" MACGO_CAMERA=1 go run main.go")

        homeDir, _ := os.UserHomeDir()
        fmt.Printf("Reading Desktop directory: %s/Desktop\n", homeDir)

        files, err := os.ReadDir(homeDir + "/Desktop")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d files\n", len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        fmt.Println("...")
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("- %s\n", file.Name())</span>
        }
        // wait for user input:
        <span class="cov0" title="0">fmt.Println("Press enter to exit")
        var input string
        fmt.Scanln(&amp;input)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Sandbox Best Practices Example
// This example demonstrates recommended patterns for working with the macOS App Sandbox
package main

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "time"

        _ "github.com/tmc/misc/macgo/auto/sandbox"
)

// Define structured logging for better understanding of sandbox behavior
func logOperation(operation, target string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf(" %s %s: %v\n", operation, target, err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" %s %s: Success\n", operation, target)
        }</span>
}

// Safely get temporary directory (always accessible in sandbox)
func getSafeTempDir() string <span class="cov0" title="0">{
        // Temporary directory is always accessible in sandbox
        tempDir := os.TempDir()
        // Create a unique subdirectory for our app
        appTempDir := filepath.Join(tempDir, "sandbox-example-"+time.Now().Format("20060102-150405"))
        os.MkdirAll(appTempDir, 0755)
        return appTempDir
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("macOS App Sandbox Best Practices Example")
        fmt.Println("========================================")
        fmt.Println()

        // 1. Demonstrate safe access to system locations
        fmt.Println("1. System Location Access Patterns")
        fmt.Println("----------------------------------")

        // Get user's home directory
        homeDir, err := os.UserHomeDir()
        logOperation("Get Home Directory", homeDir, err)

        // Get temp directory (always accessible)
        tempDir := getSafeTempDir()
        logOperation("Create Temp Directory", tempDir, nil)

        // Try accessing locations with different sandbox permissions
        locationsToCheck := []string{
                homeDir,                             // Should fail (no permission)
                filepath.Join(homeDir, "Desktop"),   // Should fail (no permission)
                filepath.Join(homeDir, "Downloads"), // May fail without specific entitlement
                tempDir,                             // Should succeed (temp is always accessible)
                "/tmp",                              // Should succeed
                "/var/tmp",                          // Should succeed
                "/private/tmp",                      // Should succeed
        }

        for _, location := range locationsToCheck </span><span class="cov0" title="0">{
                _, err := os.ReadDir(location)
                logOperation("Read Directory", location, err)
        }</span>

        // 2. Demonstrate proper file operations with security bookmarks
        <span class="cov0" title="0">fmt.Println("\n2. File Operations Best Practices")
        fmt.Println("--------------------------------")

        // Create a test file in the temp directory (always accessible)
        testFilePath := filepath.Join(tempDir, "test-file.txt")
        err = os.WriteFile(testFilePath, []byte("Test data for sandbox example"), 0644)
        logOperation("Create File", testFilePath, err)

        // Read the file back
        data, err := os.ReadFile(testFilePath)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf(" Read File %s: Content: %s\n", testFilePath, string(data))
        }</span> else<span class="cov0" title="0"> {
                logOperation("Read File", testFilePath, err)
        }</span>

        // 3. Network operations - generally allowed in sandbox
        <span class="cov0" title="0">fmt.Println("\n3. Network Access Patterns")
        fmt.Println("-------------------------")

        // Outgoing network request
        client := http.Client{
                Timeout: 5 * time.Second,
        }

        // Make a safe request to a well-known endpoint
        resp, err := client.Get("https://httpbin.org/ip")
        if err != nil </span><span class="cov0" title="0">{
                logOperation("HTTP GET", "https://httpbin.org/ip", err)
        }</span> else<span class="cov0" title="0"> {
                defer resp.Body.Close()
                body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        logOperation("Read Response", "httpbin.org", err)
                }</span> else<span class="cov0" title="0"> {
                        var ipData map[string]interface{}
                        json.Unmarshal(body, &amp;ipData)
                        fmt.Printf(" Network Request: Success - Your IP: %v\n", ipData["origin"])
                }</span>
        }

        // 4. Process execution
        <span class="cov0" title="0">fmt.Println("\n4. Process Execution Patterns")
        fmt.Println("----------------------------")

        // Execute a simple process (date command)
        cmd := exec.Command("date")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                logOperation("Execute", "date", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Execute date: Output: %s", output)
        }</span>

        // Try executing a process with arguments
        <span class="cov0" title="0">cmd = exec.Command("bash", "-c", "echo 'Hello from sandbox!'")
        output, err = cmd.CombinedOutput()
        logOperation("Execute bash -c", "echo command", err)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("   Output: %s", output)
        }</span>

        // 5. Security recommendations
        <span class="cov0" title="0">fmt.Println("\n5. Sandbox Security Best Practices")
        fmt.Println("--------------------------------")
        fmt.Println(" Always validate user input")
        fmt.Println(" Use secure default permissions (0600 for sensitive files)")
        fmt.Println(" Don't request more permissions than needed")
        fmt.Println(" Use Security-Scoped Bookmarks for persistent file access")
        fmt.Println(" Provide clear explanations for permission requests")
        fmt.Println(" Release permissions when no longer needed")
        fmt.Println(" Use temporary directory for transient files")

        // 6. Debugging sandbox issues
        fmt.Println("\n6. Debugging Sandbox Issues")
        fmt.Println("-------------------------")
        fmt.Println(" Check Console.app for sandbox violation messages")
        fmt.Println(" Use MACGO_DEBUG=1 environment variable to see debugging information")
        fmt.Println(" Inspect entitlements with: codesign -d --entitlements :- /path/to/YourApp.app")
        fmt.Println(" Verify TCC permissions in System Settings &gt; Privacy &amp; Security")
        fmt.Println(" Use log stream --predicate 'subsystem == \"com.apple.sandbox\"' for real-time logs")

        // Wait for user input before exiting
        fmt.Println("\nPress Enter to exit...")
        fmt.Scanln()

        // Clean up
        os.RemoveAll(tempDir)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"

        // Import sandboxed macgo package
        _ "github.com/tmc/misc/macgo/auto/sandbox" // --
)

func main() <span class="cov0" title="0">{
        fmt.Println("MacGo Sandboxed Example: File Access and Package Execution")
        fmt.Println("-----------------------------------------------------------")
        fmt.Println()

        // Attempt to read files from home directory (will be blocked in sandbox)
        homeDir, _ := os.UserHomeDir()
        fmt.Printf("Home directory: %s\n", homeDir)

        // Try to read various home dir locations
        dirsToTry := []string{
                homeDir,
                filepath.Join(homeDir, "Documents"),
                filepath.Join(homeDir, "Desktop"),
                filepath.Join(homeDir, "Downloads"),
                "/tmp", // This might be accessible
        }

        fmt.Println("\n1. Attempting to access directories without permission:")
        fmt.Println("-----------------------------------------------------")
        for _, dir := range dirsToTry </span><span class="cov0" title="0">{
                fmt.Printf("Reading %s: ", dir)
                files, err := os.ReadDir(dir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("ERROR: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("SUCCESS! Found %d files\n", len(files))
                for i, f := range files </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                fmt.Println("...")
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("  - %s\n", f.Name())</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Try to execute some commands
        <span class="cov0" title="0">fmt.Println("\n2. Attempting to execute commands:")
        fmt.Println("--------------------------------")
        cmdsToTry := []string{
                "ls",
                "echo Hello from subprocess",
                "whoami",
                "date",
        }

        for _, cmdStr := range cmdsToTry </span><span class="cov0" title="0">{
                fmt.Printf("Executing: %s - ", cmdStr)

                cmd := exec.Command("bash", "-c", cmdStr)
                output, err := cmd.CombinedOutput()

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("ERROR: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("SUCCESS!\n")
                if len(output) &gt; 100 </span><span class="cov0" title="0">{
                        fmt.Printf("  Output: %s...\n", output[:100])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  Output: %s\n", output)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\nPress Enter to exit...")
        fmt.Scanln()</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"
        "time"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Create a custom configuration
        cfg := macgo.NewConfig()

        // Get the name of the executable
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting executable path: %v\n", err)
                return
        }</span>

        // Try to get the real path if it's a symlink
        <span class="cov0" title="0">realPath, err := filepath.EvalSymlinks(execPath)
        if err == nil </span><span class="cov0" title="0">{
                execPath = realPath
        }</span>

        // Get the command name from os.Args[0], which preserves symlink names
        <span class="cov0" title="0">cmdName := filepath.Base(os.Args[0])
        cmdName = strings.TrimSuffix(cmdName, filepath.Ext(cmdName))

        // Use the command name for the app name
        appName := cmdName
        if appName == "" </span><span class="cov0" title="0">{
                // Fallback to executable name if args[0] doesn't work
                appName = filepath.Base(execPath)
                appName = strings.TrimSuffix(appName, filepath.Ext(appName))
        }</span>

        // Use the name for the app name
        <span class="cov0" title="0">cfg.ApplicationName = appName
        cfg.BundleID = "com.example." + strings.ToLower(appName)

        // Request necessary entitlements for osascript
        cfg.RequestEntitlements(
                macgo.EntAppSandbox,
                macgo.EntNetworkClient,
        )

        // Add AppleEvents entitlement manually - required for osascript
        cfg.AddEntitlement(macgo.Entitlement("com.apple.security.automation.apple-events"))

        // Don't show in dock
        cfg.AddPlistEntry("LSUIElement", true)

        // Apply the configuration
        macgo.Configure(cfg)

        // Enable debug logging if requested
        if os.Getenv("MACGO_DEBUG") == "1" </span><span class="cov0" title="0">{
                macgo.EnableDebug()
        }</span>

        // Start macgo
        <span class="cov0" title="0">macgo.Start()</span>
}

func main() <span class="cov0" title="0">{
        // Skip the program name (first argument)
        args := os.Args[1:]

        // Default timeout (0 means no timeout)
        var timeout time.Duration

        // Check for timeout flag
        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                if args[i] == "--timeout" &amp;&amp; i+1 &lt; len(args) </span><span class="cov0" title="0">{
                        // Parse timeout value
                        timeoutVal, err := time.ParseDuration(args[i+1])
                        if err == nil </span><span class="cov0" title="0">{
                                timeout = timeoutVal
                                // Remove --timeout and its value from args
                                args = append(args[:i], args[i+2:]...)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        // If no arguments provided, show usage
        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Usage: sandboxed-osascript [--timeout DURATION] [osascript arguments]")
                fmt.Println("\nOptions:")
                fmt.Println("  --timeout DURATION    Set a timeout for script execution (e.g. 30s, 1m)")
                fmt.Println("\nThis tool runs osascript commands from within a macOS app sandbox")
                fmt.Println("with the necessary permissions for AppleEvents.")
                return
        }</span>

        // Set up a channel to handle signals
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        fmt.Fprintf(os.Stderr, "[DEBUG] Setting up signal handlers for Interrupt and SIGTERM\n")
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM, syscall.SIGUSR1, syscall.SIGURG, syscall.SIGPIPE)

        // Prepare osascript command with all arguments
        fmt.Fprintf(os.Stderr, "[DEBUG] Creating command: osascript %v\n", args)
        cmd := exec.Command("osascript", args...)

        // Connect standard I/O
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        // Start the command
        fmt.Fprintf(os.Stderr, "[DEBUG] Starting osascript process\n")
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error starting osascript: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[DEBUG] osascript started with PID: %d\n", cmd.Process.Pid)

        // Create a channel for the command's exit
        done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[DEBUG] Waiting for osascript to complete\n")
                err := cmd.Wait()
                fmt.Fprintf(os.Stderr, "[DEBUG] osascript process completed with error: %v\n", err)
                done &lt;- err
        }</span>()

        // Create timeout channel if timeout is set
        <span class="cov0" title="0">var timeoutChan &lt;-chan time.Time
        if timeout &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[DEBUG] Setting timeout: %s\n", timeout)
                timeoutChan = time.After(timeout)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[DEBUG] Entering select loop to wait for completion/signals/timeout\n")

        // Wait for command completion, signal, or timeout
        select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                // Command completed
                fmt.Fprintf(os.Stderr, "[DEBUG] Received completion notification\n")
                if err != nil </span><span class="cov0" title="0">{
                        if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                                // Exit with the same code as osascript
                                exitCode := exitErr.ExitCode()
                                fmt.Fprintf(os.Stderr, "[DEBUG] Command failed with exit code: %d\n", exitCode)
                                os.Exit(exitCode)
                        }</span>

                        // Otherwise exit with a generic error code
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "Error running osascript: %v\n", err)
                        os.Exit(1)</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[DEBUG] Command completed successfully\n")</span>
        case sig := &lt;-sigChan:<span class="cov0" title="0">
                // Received termination signal, pass it to the child process
                fmt.Fprintf(os.Stderr, "[DEBUG] Received signal: %v (type %T), forwarding to PID %d\n",
                        sig, sig, cmd.Process.Pid)

                // Just log the PID and process status
                fmt.Fprintf(os.Stderr, "[DEBUG] Process PID: %d\n", cmd.Process.Pid)
                // We can't call Wait() here as it's already being called in the goroutine

                // Try to forward the signal
                if err := cmd.Process.Signal(sig); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "[DEBUG] Failed to send signal to osascript: %v\n", err)
                        fmt.Fprintf(os.Stderr, "[DEBUG] Attempting to kill process forcibly\n")
                        if killErr := cmd.Process.Kill(); killErr != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "[DEBUG] Kill failed: %v\n", killErr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "[DEBUG] Process killed successfully\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "[DEBUG] Signal forwarded successfully\n")

                        // Give the process a moment to handle the signal
                        fmt.Fprintf(os.Stderr, "[DEBUG] Waiting briefly for process to handle signal\n")
                        time.Sleep(500 * time.Millisecond)

                        // We can't check process state here since we're already waiting in the goroutine
                        // Just add a log message
                        fmt.Fprintf(os.Stderr, "[DEBUG] Waiting for process to exit after signal\n")
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[DEBUG] Exiting with code 1 due to signal\n")
                os.Exit(1)</span>
        case &lt;-timeoutChan:<span class="cov0" title="0">
                // Timeout reached, kill the process
                fmt.Fprintf(os.Stderr, "[DEBUG] Timeout of %s reached, terminating osascript (PID: %d)\n",
                        timeout, cmd.Process.Pid)

                if killErr := cmd.Process.Kill(); killErr != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "[DEBUG] Kill failed: %v\n", killErr)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "[DEBUG] Process killed successfully\n")
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "[DEBUG] Exiting with code 1 due to timeout\n")
                os.Exit(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Security-Scoped Bookmarks Example
// Demonstrates how to use security-scoped bookmarks for persistent file access
// Note: This example requires CGO due to the need for Objective-C APIs
package main

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/tmc/misc/macgo"
)

/*
Note: This example demonstrates conceptually how security-scoped bookmarks work,
but doesn't include actual implementation since it requires CGO and Objective-C.

In a real implementation, you would use:
1. The NSURL startAccessingSecurityScopedResource API
2. The NSURL bookmarkDataWithOptions API
3. Store bookmark data persistently between app launches

The macgo package doesn't currently provide a native Go API for security-scoped
bookmarks, so this example is for educational purposes.
*/

func init() <span class="cov0" title="0">{
        // Create a custom configuration for security-scoped bookmarks
        cfg := macgo.NewConfig()

        // Set application details
        cfg.ApplicationName = "SecurityBookmarksExample"
        cfg.BundleID = "com.example.macgo.security-bookmarks"

        // Request sandbox
        cfg.AddEntitlement(macgo.EntAppSandbox)

        // Add user-selected file access (read/write)
        cfg.AddEntitlement(macgo.EntUserSelectedReadWrite)

        // Add security-scoped bookmark entitlement
        // This allows storing and using bookmarks to access files across launches
        cfg.AddEntitlement("com.apple.security.files.bookmarks.app-scope")

        // Enable debug logging
        macgo.EnableDebug()

        // Apply configuration
        macgo.Configure(cfg)

        // Initialize
        macgo.Start()
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("macOS Security-Scoped Bookmarks Example")
        fmt.Println("=======================================")
        fmt.Println("This example explains how security-scoped bookmarks work.")
        fmt.Println()

        // Get user's home directory
        homeDir, _ := os.UserHomeDir()

        // Security-scoped bookmarks conceptual explanation
        fmt.Println("About Security-Scoped Bookmarks")
        fmt.Println("------------------------------")
        fmt.Println("Security-scoped bookmarks allow your app to maintain access to")
        fmt.Println("user-selected files and folders across app launches.")
        fmt.Println()
        fmt.Println("The typical workflow is:")
        fmt.Println("1. User selects a file/folder (usually through NSOpenPanel)")
        fmt.Println("2. App creates a persistent bookmark using NSURL bookmarkDataWithOptions")
        fmt.Println("3. App stores the bookmark data (e.g., in UserDefaults)")
        fmt.Println("4. On next launch, app resolves the bookmark to regain access")
        fmt.Println("5. App calls startAccessingSecurityScopedResource before access")
        fmt.Println("6. App calls stopAccessingSecurityScopedResource when done")
        fmt.Println()

        // Example folder we want to access
        targetFolder := filepath.Join(homeDir, "Documents")
        fmt.Printf("Target folder we want persistent access to: %s\n", targetFolder)
        fmt.Println()

        // Simulate bookmark creation (actual implementation needs CGO/Objective-C)
        fmt.Println("Creating a Security-Scoped Bookmark")
        fmt.Println("---------------------------------")
        fmt.Println("// In real code, you would do something like this:")
        fmt.Println("import \"github.com/progrium/macdriver/cocoa\"")
        fmt.Println("import \"github.com/progrium/macdriver/objc\"")
        fmt.Println()
        fmt.Println("func createBookmark(path string) ([]byte, error) {")
        fmt.Println("    url := cocoa.NSURL.fileURLWithPath(path)")
        fmt.Println("    options := cocoa.NSURLBookmarkCreationWithSecurityScope")
        fmt.Println("    bookmarkData, err := url.bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error(")
        fmt.Println("        options, nil, nil)")
        fmt.Println("    if err != nil {")
        fmt.Println("        return nil, err")
        fmt.Println("    }")
        fmt.Println("    return bookmarkData.toBytes(), nil")
        fmt.Println("}")
        fmt.Println()

        // Simulate accessing files via bookmark
        fmt.Println("Accessing Files via Bookmark")
        fmt.Println("---------------------------")
        fmt.Println("// In real code, you would do something like this:")
        fmt.Println("func accessBookmarkedPath(bookmarkData []byte) (string, func(), error) {")
        fmt.Println("    data := cocoa.NSData.dataWithBytes(bookmarkData)")
        fmt.Println("    url, isStale, err := cocoa.NSURL.URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(")
        fmt.Println("        data, cocoa.NSURLBookmarkResolutionWithSecurityScope, nil)")
        fmt.Println("    if err != nil {")
        fmt.Println("        return \"\", nil, err")
        fmt.Println("    }")
        fmt.Println("    if isStale {")
        fmt.Println("        // Consider refreshing the bookmark")
        fmt.Println("    }")
        fmt.Println("    success := url.startAccessingSecurityScopedResource()")
        fmt.Println("    if !success {")
        fmt.Println("        return \"\", nil, errors.New(\"failed to access security scoped resource\")")
        fmt.Println("    }")
        fmt.Println("    cleanup := func() {")
        fmt.Println("        url.stopAccessingSecurityScopedResource()")
        fmt.Println("    }")
        fmt.Println("    return url.path(), cleanup, nil")
        fmt.Println("}")
        fmt.Println()

        // Security considerations
        fmt.Println("Security Considerations")
        fmt.Println("----------------------")
        fmt.Println(" Don't keep security-scoped resources open longer than needed")
        fmt.Println(" Always call stopAccessingSecurityScopedResource when done")
        fmt.Println(" Handle stale bookmarks appropriately")
        fmt.Println(" Use app-scoped bookmarks for most applications")
        fmt.Println(" Document-scoped bookmarks are for document-based apps")

        fmt.Println("\nPress Enter to exit...")
        fmt.Scanln()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Signal Capturing Utility
// This example is a simple utility that captures and logs signals it receives
package main

import (
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"
)

func main() <span class="cov0" title="0">{
        // Create a signal log file
        logPath := filepath.Join(os.TempDir(), fmt.Sprintf("macgo-signal-log-%d.txt", os.Getpid()))
        logFile, err := os.Create(logPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error creating log file: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        // Log startup info
        fmt.Fprintf(logFile, "Signal capture started at %s\n", time.Now().Format(time.RFC3339))
        fmt.Fprintf(logFile, "PID: %d\n", os.Getpid())
        fmt.Fprintf(logFile, "PPID: %d\n", os.Getppid())
        fmt.Fprintf(logFile, "Args: %v\n\n", os.Args)
        logFile.Sync()

        // Also output to console
        fmt.Println("Signal Capture Utility")
        fmt.Println("====================")
        fmt.Printf("PID: %d\n", os.Getpid())
        fmt.Printf("Logging signals to: %s\n", logPath)
        fmt.Println("Press Ctrl+C to test or use kill command")

        // Set up signal handling
        sigCh := make(chan os.Signal, 10)
        signal.Notify(sigCh,
                syscall.SIGINT,
                syscall.SIGTERM,
                syscall.SIGHUP,
                syscall.SIGQUIT,
                syscall.SIGTSTP,
                syscall.SIGTTIN,
                syscall.SIGTTOU,
        )

        // Wait for signals
        for sig := range sigCh </span><span class="cov0" title="0">{
                now := time.Now().Format(time.RFC3339Nano)
                sigMessage := fmt.Sprintf("[%s] Received signal: %v\n", now, sig)

                // Log to file
                fmt.Fprint(logFile, sigMessage)
                logFile.Sync()

                // Output to console
                fmt.Print(sigMessage)

                // Exit on termination signals
                if sig == syscall.SIGINT || sig == syscall.SIGTERM </span><span class="cov0" title="0">{
                        fmt.Fprintf(logFile, "[%s] Exiting due to signal: %v\n", now, sig)
                        fmt.Printf("Exiting due to signal: %v\n", sig)
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Signal Debugging Utility
// This example helps diagnose signal handling and forwarding issues
package main

import (
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Set up basic configuration
        macgo.SetAppName("SignalDebugApp")
        macgo.SetBundleID("com.example.macgo.signaldebug")

        // Enable improved signal handling for testing
        macgo.EnableImprovedSignalHandling()

        // Enable debug output to see what's happening
        macgo.EnableDebug()
}</span>

func main() <span class="cov0" title="0">{
        // Check if we're in child mode
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "child" </span><span class="cov0" title="0">{
                runChild()
                return
        }</span>

        // Start macgo - this creates the app bundle and relaunches if needed
        <span class="cov0" title="0">macgo.Start()

        fmt.Println("Signal Debugging Utility")
        fmt.Println("=======================")
        fmt.Println("This utility helps diagnose signal handling issues")
        fmt.Println("Parent PID:", os.Getpid())
        fmt.Println()

        // Set up a signal monitor to log all signals received
        allSignals := make(chan os.Signal, 100)
        signal.Notify(allSignals)
        go func() </span><span class="cov0" title="0">{
                for sig := range allSignals </span><span class="cov0" title="0">{
                        fmt.Printf("[Parent] Received signal: %v\n", sig)
                }</span>
        }()

        // Launch a child process
        <span class="cov0" title="0">cmd := exec.Command(os.Args[0], "child")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setpgid: true,
        }

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error starting child: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Started child process with PID: %d\n", cmd.Process.Pid)
        fmt.Println("Process hierarchy:")
        fmt.Printf("  - Parent (this process): PID %d\n", os.Getpid())
        fmt.Printf("  - Child process: PID %d\n", cmd.Process.Pid)
        fmt.Println()
        fmt.Println("Testing signal propagation...")
        fmt.Println("1. Press Ctrl+C to test SIGINT handling")
        fmt.Println("2. Run 'kill -TERM &lt;parent-pid&gt;' to test SIGTERM")
        fmt.Println("3. Run 'kill -STOP &lt;parent-pid&gt;' to test SIGTSTP")
        fmt.Println()

        // Wait for signals or timeout
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                cmd.Wait()
                fmt.Println("Child process exited")
                close(done)
        }</span>()

        // Run for 60 seconds or until done
        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                fmt.Println("Child process terminated")</span>
        case &lt;-time.After(60 * time.Second):<span class="cov0" title="0">
                fmt.Println("Timeout reached, exiting")</span>
        }
}

// Child process - just waits for signals
func runChild() <span class="cov0" title="0">{
        fmt.Printf("[Child] Started with PID: %d\n", os.Getpid())

        // Set up signal handling
        allSignals := make(chan os.Signal, 100)
        signal.Notify(allSignals)

        // Process signal info
        go func() </span><span class="cov0" title="0">{
                for sig := range allSignals </span><span class="cov0" title="0">{
                        fmt.Printf("[Child] Received signal: %v\n", sig)

                        // Exit on termination signals
                        if sig == syscall.SIGINT || sig == syscall.SIGTERM </span><span class="cov0" title="0">{
                                fmt.Println("[Child] Exiting due to termination signal")
                                os.Exit(1)
                        }</span>
                }
        }()

        // Print process group info
        <span class="cov0" title="0">pgid, err := syscall.Getpgid(os.Getpid())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[Child] Error getting PGID: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("[Child] Process Group ID: %d\n", pgid)
        }</span>

        // Print parent process info
        <span class="cov0" title="0">ppid := os.Getppid()
        fmt.Printf("[Child] Parent PID: %d\n", ppid)

        // Run ps to show process hierarchy
        cmd := exec.Command("ps", "-o", "pid,ppid,pgid,command", "-p", fmt.Sprintf("%d,%d", os.Getpid(), ppid))
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[Child] Error running ps: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("[Child] Process hierarchy:")
                fmt.Println(strings.TrimSpace(string(output)))
        }</span>

        // Wait for signals until terminated
        <span class="cov0" title="0">fmt.Println("[Child] Waiting for signals...")
        select </span>{}
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Signal Handling Test Example
// This example demonstrates the improved signal handling with IO redirection in macgo
package main

import (
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Set up basic configuration
        macgo.SetAppName("SignalTestApp")
        macgo.SetBundleID("com.example.macgo.signaltest")

        // Enable improved signal handling with IO redirection
        // This provides better Ctrl+C handling and preserves stdin/stdout/stderr
        macgo.EnableImprovedSignalHandling()

        // Enable debug output to see what's happening
        macgo.EnableDebug()
}</span>

func main() <span class="cov0" title="0">{
        // Start macgo - this creates the app bundle and relaunches if needed
        // Using the improved signal handling with IO redirection
        macgo.Start()

        fmt.Println("Signal Handling Test")
        fmt.Println("===================")
        fmt.Println("Press Ctrl+C to test signal handling")
        fmt.Println("The application should exit gracefully")
        fmt.Println()

        // Set up a channel to listen for signals
        c := make(chan os.Signal, 1)
        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)

        // Display a countdown
        go func() </span><span class="cov0" title="0">{
                for i := 30; i &gt; 0; i-- </span><span class="cov0" title="0">{
                        fmt.Printf("\rWaiting... %d seconds remaining", i)
                        time.Sleep(1 * time.Second)
                }</span>
                <span class="cov0" title="0">fmt.Println("\rTimeout reached, exiting normally        ")</span>
        }()

        // Wait for a signal or timeout
        <span class="cov0" title="0">sig := &lt;-c
        fmt.Printf("\n\nReceived signal: %v\n", sig)
        fmt.Println("Exiting gracefully")</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package main

import (
        "fmt"
        "os"

        // Import macgo package directly
        _ "github.com/tmc/misc/macgo/auto" // --
)

func main() <span class="cov0" title="0">{
        fmt.Println("MacGo Simple Example")
        fmt.Println()

        // Show some protected directories
        homeDir, _ := os.UserHomeDir()
        dirs := []string{
                homeDir + "/Desktop",
                homeDir + "/Downloads",
        }

        for _, dir := range dirs </span><span class="cov0" title="0">{
                fmt.Printf("Reading %s: ", dir)
                files, err := os.ReadDir(dir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("%d files found\n", len(files))
                for i, f := range files </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                fmt.Println("...")
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("- %s\n", f.Name())</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Specific Folder Access Example
// Demonstrates how to access specific folders with entitlements
package main

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Create a custom configuration for specific folder access
        cfg := macgo.NewConfig()

        // Set application details
        cfg.ApplicationName = "FolderAccessExample"
        cfg.BundleID = "com.example.macgo.folder-access"

        // Request sandbox (default)
        cfg.AddEntitlement(macgo.EntAppSandbox)

        // Add specific folder access entitlements
        // Unlike user-selected files which prompt at runtime,
        // these provide access to standard folders without prompting
        // but require explicit entitlements
        cfg.RequestEntitlements(
                // Standard folder access
                macgo.EntDownloadsReadOnly, // Read access to Downloads folder
                macgo.EntPicturesReadOnly,  // Read access to Pictures folder
                macgo.EntMusicReadOnly,     // Read access to Music folder
                macgo.EntMoviesReadOnly,    // Read access to Movies folder

                // For Applications (not usually needed)
                // "com.apple.security.files.bookmarks.app-scope",  // For security-scoped bookmarks

                // Uncomment for write access (use carefully)
                // macgo.EntDownloadsReadWrite,    // Read/write access to Downloads folder
                // macgo.EntPicturesReadWrite,     // Read/write access to Pictures folder
        )

        // Enable debug logging
        macgo.EnableDebug()

        // Apply configuration
        macgo.Configure(cfg)

        // Initialize
        macgo.Start()
}</span>

// Helper to read and display directory contents
func listDirectory(path string) <span class="cov0" title="0">{
        fmt.Printf("Reading %s: ", path)

        files, err := os.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("ERROR: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("SUCCESS! Found %d files\n", len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        fmt.Println("...")
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("  - %s\n", file.Name())</span>
        }
        <span class="cov0" title="0">fmt.Println()</span>
}

func main() <span class="cov0" title="0">{
        fmt.Println("macOS Specific Folder Access Example")
        fmt.Println("====================================")
        fmt.Println("This example demonstrates accessing specific folders with entitlements.")
        fmt.Println()

        // Get standard directories
        homeDir, _ := os.UserHomeDir()

        // These should succeed with the specific entitlements
        fmt.Println("1. Standard Folders with Entitlements")
        fmt.Println("------------------------------------")
        listDirectory(filepath.Join(homeDir, "Downloads"))
        listDirectory(filepath.Join(homeDir, "Pictures"))
        listDirectory(filepath.Join(homeDir, "Music"))
        listDirectory(filepath.Join(homeDir, "Movies"))

        // These should fail (no entitlements)
        fmt.Println("2. Folders without Specific Entitlements")
        fmt.Println("---------------------------------------")
        listDirectory(filepath.Join(homeDir, "Documents"))
        listDirectory(homeDir) // Home directory itself

        // These should succeed (access always allowed)
        fmt.Println("3. Folders Always Accessible")
        fmt.Println("---------------------------")
        listDirectory(os.TempDir())
        listDirectory("/tmp")

        // Creating files in Downloads (requires read-write entitlement)
        fmt.Println("4. Write Access Test (requires EntDownloadsReadWrite)")
        fmt.Println("-------------------------------------------------")
        testFilePath := filepath.Join(homeDir, "Downloads", "macgo-test.txt")
        err := os.WriteFile(testFilePath, []byte("Test file for macgo specific folder access"), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Writing to %s: ERROR: %v\n", testFilePath, err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Writing to %s: SUCCESS!\n", testFilePath)
                // Clean up
                os.Remove(testFilePath)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nPress Enter to exit...")
        fmt.Scanln()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package main

import (
        "fmt"
        "os"
        "time"

        "github.com/tmc/misc/macgo"
        "github.com/tmc/misc/macgo/debug"
)

func init() <span class="cov0" title="0">{
        debug.Init()
        macgo.EnableDebug()
        macgo.Start()
}</span>

func main() <span class="cov0" title="0">{
        fmt.Printf("=== CHILD PROCESS OUTPUT ===\n")
        fmt.Printf("PID: %d\n", os.Getpid())
        fmt.Printf("In app bundle: %t\n", macgo.IsInAppBundle())
        fmt.Printf("Args: %v\n", os.Args)
        fmt.Printf("Working dir: %s\n", getWorkingDir())

        // Test stdout
        fmt.Println("This should appear on stdout")

        // Test stderr
        fmt.Fprintln(os.Stderr, "This should appear on stderr")

        // Test with explicit flush
        fmt.Print("Flushing stdout...")
        os.Stdout.Sync()
        fmt.Println(" done")

        fmt.Print("Flushing stderr...")
        os.Stderr.Sync()
        fmt.Fprintln(os.Stderr, " done")

        fmt.Println("=== END CHILD OUTPUT ===")

        // Short wait to ensure output is flushed
        time.Sleep(100 * time.Millisecond)
}</span>

func getWorkingDir() string <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error: %v", err)
        }</span>
        <span class="cov0" title="0">return dir</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package signalhandler provides automatic initialization for macgo with app sandboxing
// and improved signal handling using the Go tool's signal handling pattern.
//
// Import this package to automatically set up app sandboxing on startup with improved signal handling:
//
//        import (
//            _ "github.com/tmc/misc/macgo/auto/sandbox/signalhandler"
//        )
//
// This will automatically enable app sandboxing and create the app bundle with improved signal handling.
package signalhandler

import (
        "os"
        "os/exec"
        "os/signal"
        "syscall"

        "github.com/tmc/misc/macgo"
)

func init() <span class="cov0" title="0">{
        // Replace the default relaunch function with our improved one
        macgo.SetReLaunchFunction(improvedRelaunch)
}</span>

// Improved relaunch that uses the Go tool's signal handling pattern
// which is more robust than the previous approach
func improvedRelaunch(appPath, execPath string, args []string) <span class="cov0" title="0">{
        // Set environment to prevent relaunching again
        os.Setenv("MACGO_NO_RELAUNCH", "1")

        // Launch app bundle with more robust approach
        toolPath, err := exec.LookPath("open")
        if err != nil </span><span class="cov0" title="0">{
                macgo.Debug("error finding open command: %v", err)
                return
        }</span>

        <span class="cov0" title="0">toolCmd := &amp;exec.Cmd{
                Path:   toolPath,
                Args:   append([]string{toolPath}, args...),
                Stdin:  os.Stdin,
                Stdout: os.Stdout,
                Stderr: os.Stderr,
                SysProcAttr: &amp;syscall.SysProcAttr{
                        Setpgid: true,
                        Pgid:    0, // Use the parent's process group
                },
        }

        err = toolCmd.Start()
        if err == nil </span><span class="cov0" title="0">{
                c := make(chan os.Signal, 100)
                signal.Notify(c)
                go func() </span><span class="cov0" title="0">{
                        for sig := range c </span><span class="cov0" title="0">{
                                macgo.Debug("Forwarding signal %v to app bundle process group", sig)
                                // Forward to entire process group using negative PID
                                sigNum := sig.(syscall.Signal)

                                // Skip SIGCHLD as we don't need to forward it
                                if sigNum == syscall.SIGCHLD </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Using negative PID sends to the entire process group
                                <span class="cov0" title="0">if err := syscall.Kill(-toolCmd.Process.Pid, sigNum); err != nil </span><span class="cov0" title="0">{
                                        macgo.Debug("Error forwarding signal %v: %v", sigNum, err)
                                }</span>

                                // Special handling for terminal signals
                                <span class="cov0" title="0">if sigNum == syscall.SIGTSTP || sigNum == syscall.SIGTTIN || sigNum == syscall.SIGTTOU </span><span class="cov0" title="0">{
                                        // Use SIGSTOP for terminal signals
                                        syscall.Kill(syscall.Getpid(), syscall.SIGSTOP)
                                }</span>
                        }
                }()
                <span class="cov0" title="0">err = toolCmd.Wait()
                signal.Stop(c)
                close(c)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Only print about the exit status if the command
                // didn't even run or it didn't exit cleanly
                if e, ok := err.(*exec.ExitError); !ok || !e.Exited() </span><span class="cov0" title="0">{
                        macgo.Debug("error waiting for app bundle: %v", err)
                }</span>
                <span class="cov0" title="0">if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        os.Exit(exitErr.ExitCode())
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">os.Exit(0)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
